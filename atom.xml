<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江城子的博客</title>
  
  
  <link href="https://blog.jiangchen.tech/atom.xml" rel="self"/>
  
  <link href="https://blog.jiangchen.tech/"/>
  <updated>2022-04-29T16:00:00.000Z</updated>
  <id>https://blog.jiangchen.tech/</id>
  
  <author>
    <name>江城子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JEP-425 Virtual Threads (Preview)</title>
    <link href="https://blog.jiangchen.tech/2022/04/910d18dc.html"/>
    <id>https://blog.jiangchen.tech/2022/04/910d18dc.html</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-04-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>提示：本文翻译的时候，文档最新版本是 2022&#x2F;04&#x2F;29，所以本文可能存在一定的时效性问题，请读者注意。</p></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>将<em>虚拟线程</em>引入到 Java 平台。虚拟线程是轻量级的线程，可以大大减少编写、维护和监测高吞吐量并发应用程序的工作量。这是 <a href="https://openjdk.java.net/jeps/12">预览 API</a> .</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>使以简单的线程每请求方式编写的服务器应用程序能够以接近最佳的硬件利用率进行扩展。</li><li>让使用 <code>java.lang.Thread</code> API 的现有代码能够以最小的改动采用虚拟线程。</li><li>使用现有的 JDK 工具轻松地对虚拟线程进行故障排除、调试和分析。<span id="more"></span><h2 id="非目标"><a href="#非目标" class="headerlink" title="非目标"></a>非目标</h2></li><li>我们的目标不是移除线程的传统实现，也不是默默地将现有的应用程序迁移到使用虚拟线程。</li><li>它的目标不是改变 Java 的基本并发模型。</li><li>在 Java 语言或 Java 库中提供新的数据并行结构不是我们的目标。流 API 仍然是并行处理大型数据集的首选方式。</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>近三十年来，Java 开发者一直依赖线程作为并发服务器应用程序的构建基础模块。每个方法中的每条语句都在一个线程中执行，由于 Java 是多线程的，所以多个执行线程同时发生。线程是 Java 的并发单元：一段顺序代码，与其他此类单元同时运行，而且基本上是独立的。每个线程都提供一个堆栈来存储局部变量和协调方法调用，以及出错时的上下文：异常是由同一线程中的方法抛出和捕获的，因此开发人员可以使用线程的堆栈跟踪来找出发生了什么。线程也是工具的一个核心概念：调试器通过线程方法中的语句，剖析器将多个线程的行为可视化，以帮助了解其性能。</p><h3 id="线程每请求的风格"><a href="#线程每请求的风格" class="headerlink" title="线程每请求的风格"></a>线程每请求的风格</h3><p>服务器应用程序通常处理相互独立的并发用户请求，因此，应用程序通过在整个请求期间为该请求分配一个线程来处理请求是合理的。这种线程每请求的风格容易理解，容易编程，也容易调试和分析，因为它使用操作系统平台的最小并发单元来代表应用程序的并发单元。</p><p>服务器应用程序的可扩展性受 Little 定律的制约，该定律将延迟、并发性和吞吐量联系起来。对于一个给定的请求处理时间（即延迟），应用程序同时处理的请求数量（即并发性）必须与到达率（即吞吐量）成比例增长。例如，假设一个平均延迟为 50ms 的应用程序，通过并发处理 10 个请求，达到每秒 200 个请求的吞吐量。为了使该应用程序扩展到每秒 2000 个请求的吞吐量，它将需要同时处理 100 个请求。如果每个请求都在一个线程中处理，那么，为了使应用程序跟上，线程的数量必须随着吞吐量的增长而增长。</p><p>不幸的是，可用的线程数量是有限的，因为 JDK 将线程作为操作系统线程的封装来实现。操作系统线程的调度成本很高，所以我们不能有太多的线程，这使得该实现不适合线程每请求的方式。如果每个请求在其持续时间内消耗一个线程，也就是一个操作系统线程，那么线程的数量往往在其他资源（如 CPU 或网络连接）耗尽之前就已经成为限制因素了。JDK 目前对线程的实现将应用程序的吞吐量限制在一个远远低于硬件所能支持的水平。即使线程是池化的，这种情况也会发生，因为池化有助于避免启动新线程的高成本，但不会增加线程的总数。</p><h3 id="用异步风格提高可扩展性"><a href="#用异步风格提高可扩展性" class="headerlink" title="用异步风格提高可扩展性"></a>用异步风格提高可扩展性</h3><p>一些希望最大限度地利用硬件的开发者已经放弃了线程每请求风格，而选择了线程共享风格。请求处理代码不是从头到尾在一个线程上处理一个请求，而是在等待一个 I&#x2F;O 操作完成时将其线程返回到一个池中，以便该线程可以为其他请求提供服务。这种细粒度的线程共享，即代码只在执行计算时保留线程，而不是在等待 I&#x2F;O 时保留线程，允许大量的并发操作而不消耗大量的线程。虽然它消除了操作系统线程稀缺性对吞吐量的限制，但它的代价很高。它需要所谓的异步编程风格，采用一套独立的 I&#x2F;O 方法，不等待 I&#x2F;O 操作的完成，而是在以后向回调发出完成信号。如果没有专门的线程，开发者必须将他们的请求处理逻辑分解成小的阶段，通常写成 lambda 表达式，然后用 API 将它们组成一个顺序管道（例如 CompletableFuture，或所谓的 “反应式 “框架）。因此，他们放弃了语言的基本顺序组合操作符，如循环和 try&#x2F;catch 块。</p><p>在异步风格中，一个请求的每个阶段可能在不同的线程上执行，每个线程以交错的方式运行属于不同请求的阶段。这对理解程序行为有深刻的影响。堆栈跟踪没有提供可用的上下文，调试器不能穿过请求处理逻辑，剖析器不能将一个操作的成本与它的调用者联系起来。当使用 Java 的流 API 来处理短管道中的数据时，组成 lambda 表达式是可以管理的，但当应用程序中所有的请求处理代码都必须以这种方式编写时，就会出现问题。这种编程风格与 Java 平台不一致，因为应用程序的并发单元，即异步流水线，不再是平台的并发单位了。</p><h3 id="使用虚拟线程保留线程线程每请求每请求的风格"><a href="#使用虚拟线程保留线程线程每请求每请求的风格" class="headerlink" title="使用虚拟线程保留线程线程每请求每请求的风格"></a>使用虚拟线程保留线程线程每请求每请求的风格</h3><p>为了使应用程序能够扩展，同时与平台保持和谐，我们应该努力通过更有效地实现线程来保留线程每请求的风格，这样它们就会更多。操作系统无法更有效地实现操作系统线程，因为不同的语言和运行时以不同的方式使用线程栈。然而，Java 运行时有可能以一种切断与操作系统线程的一对一对应关系的方式来实现 Java 线程。就像操作系统通过将大量的虚拟地址空间映射到有限的物理 RAM 上，给人以内存充足的错觉一样，Java 运行时也可以通过将大量的虚拟线程映射到少量的操作系统线程上，给人以线程充足的错觉。</p><p>虚拟线程是 <code>java.lang.Thread</code> 的一个实例，它不与特定的操作系统线程相联系。相比之下，平台线程是以传统方式实现的 <code>java.lang.Thread</code> 的一个实例，作为操作系统线程的一个封装。</p><p>线程每请求风格的应用程序代码可以在请求的整个过程中在虚拟线程中运行，但虚拟线程只在 CPU 上执行计算时消耗一个操作系统线程。其结果是与异步风格相同的可扩展性，只是它是以透明方式实现的。当在虚拟线程中运行的代码调用 java.* API 中的阻塞 I&#x2F;O 操作时，运行时会执行一个非阻塞的操作系统调用，并自动暂停虚拟线程，直到以后可以恢复。对 Java 开发者来说，虚拟线程只是创建成本低且几乎无限多的线程。硬件利用率接近最佳，允许高水平的并发，因此，具有很高的吞吐量，与此同时应用程序仍然与 Java 平台的多线程设计及其工具相协调。</p><h3 id="虚拟线程的影响"><a href="#虚拟线程的影响" class="headerlink" title="虚拟线程的影响"></a>虚拟线程的影响</h3><p>虚拟线程开销低，数量众多，因此没必要池化使用：每个任务都应创建一个新的虚拟线程。因此，大多数虚拟线程都是短命的，而且调用栈很浅，只执行一次 HTTP 客户端调用或一次 JDBC 查询。相比之下，操作系统线程是重量级和昂贵的，因此往往必须是池化的。它们往往寿命很长，有很深的调用栈，并在许多任务之间共享使用。</p><p>总之，虚拟线程保留了与 Java 平台设计相协调的可靠的线程每请求风格，同时优化了硬件的利用。使用虚拟线程不需要学习新的概念，尽管它可能需要忘掉为应对今天的高线程成本而养成的习惯。虚拟线程不仅能帮助应用开发者，还能帮助框架设计者提供易于使用的 API，这些 API 与平台的设计兼容，同时又不影响扩展性。</p><blockquote><p>To be continue …</p></blockquote><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p> <a href="https://openjdk.java.net/jeps/425">JEP 425: Virtual Threads (Preview)</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;提示：本文翻译的时候，文档最新版本是 2022&amp;#x2F;04&amp;#x2F;29，所以本文可能存在一定的时效性问题，请读者注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;p&gt;将&lt;em&gt;虚拟线程&lt;/em&gt;引入到 Java 平台。虚拟线程是轻量级的线程，可以大大减少编写、维护和监测高吞吐量并发应用程序的工作量。这是 &lt;a href=&quot;https://openjdk.java.net/jeps/12&quot;&gt;预览 API&lt;/a&gt; .&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使以简单的线程每请求方式编写的服务器应用程序能够以接近最佳的硬件利用率进行扩展。&lt;/li&gt;
&lt;li&gt;让使用 &lt;code&gt;java.lang.Thread&lt;/code&gt; API 的现有代码能够以最小的改动采用虚拟线程。&lt;/li&gt;
&lt;li&gt;使用现有的 JDK 工具轻松地对虚拟线程进行故障排除、调试和分析。</summary>
    
    
    
    <category term="翻译" scheme="https://blog.jiangchen.tech/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="JEP" scheme="https://blog.jiangchen.tech/tags/jep/"/>
    
    <category term="Java" scheme="https://blog.jiangchen.tech/tags/java/"/>
    
    <category term="翻译" scheme="https://blog.jiangchen.tech/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="协程" scheme="https://blog.jiangchen.tech/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM 相关总结（三）</title>
    <link href="https://blog.jiangchen.tech/2021/05/f7703578.html"/>
    <id>https://blog.jiangchen.tech/2021/05/f7703578.html</id>
    <published>2021-05-01T16:29:21.000Z</published>
    <updated>2021-05-01T16:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-相关总结（三）"><a href="#JVM-相关总结（三）" class="headerlink" title="JVM 相关总结（三）"></a>JVM 相关总结（三）</h1><h2 id="GC-日志解读与分析"><a href="#GC-日志解读与分析" class="headerlink" title="GC 日志解读与分析"></a>GC 日志解读与分析</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示 GC 日志生成与解读</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogAnalysis</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前毫秒时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 持续运行毫秒数；可根据需要进行修改</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> TimeUnit.SECONDS.toMillis(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 结束时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endMillis</span> <span class="operator">=</span> startMillis + timeoutMillis;</span><br><span class="line">        <span class="type">LongAdder</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行。..&quot;</span>);</span><br><span class="line">        <span class="comment">// 缓存一部分对象；进入老年代</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cacheSize</span> <span class="operator">=</span> <span class="number">2000</span>;</span><br><span class="line">        Object[] cachedGarbage = <span class="keyword">new</span> <span class="title class_">Object</span>[cacheSize];</span><br><span class="line">        <span class="comment">// 在此时间范围内，持续循环</span></span><br><span class="line">        <span class="keyword">while</span> (System.currentTimeMillis() &lt; endMillis) &#123;</span><br><span class="line">            <span class="comment">// 生成垃圾对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">garbage</span> <span class="operator">=</span> generateGarbage(<span class="number">100</span> * <span class="number">1024</span>);</span><br><span class="line">            counter.increment();</span><br><span class="line">            <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> random.nextInt(<span class="number">2</span> * cacheSize);</span><br><span class="line">            <span class="keyword">if</span> (randomIndex &lt; cacheSize) &#123;</span><br><span class="line">                cachedGarbage[randomIndex] = garbage;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行结束！共生成对象次数：&quot;</span> + counter.longValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">generateGarbage</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomSize</span> <span class="operator">=</span> random.nextInt(max);</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> randomSize % <span class="number">4</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                result = <span class="keyword">new</span> <span class="title class_">int</span>[randomSize];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                result = <span class="keyword">new</span> <span class="title class_">byte</span>[randomSize];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                result = <span class="keyword">new</span> <span class="title class_">double</span>[randomSize];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">String</span> <span class="variable">randomString</span> <span class="operator">=</span> <span class="string">&quot;randomString-Anything&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (builder.length() &lt; randomSize) &#123;</span><br><span class="line">                    builder.append(randomString);</span><br><span class="line">                    builder.append(max);</span><br><span class="line">                    builder.append(randomSize);</span><br><span class="line">                &#125;</span><br><span class="line">                result = builder.toString();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串行-x2F-并行-x2F-G1-案例演练"><a href="#串行-x2F-并行-x2F-G1-案例演练" class="headerlink" title="串行&#x2F;并行&#x2F;G1 案例演练"></a>串行&#x2F;并行&#x2F;G1 案例演练</h3><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><blockquote><p>java -XX:+UseSerialGC -Xloggc:gc.log -Xms128m -Xmx128m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseSerialGC -Xloggc:gc.log -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseSerialGC -Xloggc:gc.log -Xms4g -Xmx4g -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><blockquote><p>java -XX:+UseParallelGC -Xloggc:gc.log -Xms128m -Xmx128m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseParallelGC -Xloggc:gc.log -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseParallelGC -Xloggc:gc.log -Xms4g -Xmx4g -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><blockquote><p>java -XX:+UseConcMarkSweepGC -Xloggc:gc.log -Xms128m -Xmx128m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseConcMarkSweepGC -Xloggc:gc.log -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseConcMarkSweepGC -Xloggc:gc.log -Xms4g -Xmx4g -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><blockquote><p>java -XX:+UseG1GC -Xloggc:gc.log -Xms128m -Xmx128m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseG1GC -Xloggc:gc.log -Xms512m -Xmx512m -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><blockquote><p>java -XX:+UseG1GC -Xloggc:gc.log -Xms4g -Xmx4g -XX:+PrintGCDetails -XX:+PrintGCDateStamps GCLogAnalysis</p></blockquote><h4 id="汇总表格"><a href="#汇总表格" class="headerlink" title="汇总表格"></a>汇总表格</h4><table><thead><tr><th align="left">堆内存大小</th><th align="left">Serial GC</th><th align="left">Parallel GC</th><th align="left">CMS GC</th><th align="left">G1 GC</th></tr></thead><tbody><tr><td align="left">128M</td><td align="left">OOM（26 次 GC，20 次 Full GC）</td><td align="left">OOM（27 次 GC，17 次 Full GC）</td><td align="left">OOM（24 次 GC，13 次 Full GC）</td><td align="left">OOM（34 次 GC，11 次 Full GC）</td></tr><tr><td align="left">512M</td><td align="left">6837（13 次 GC，4 次 Full GC）</td><td align="left">6933（28 次 GC，4 次 Full GC）</td><td align="left">9023（29 次 GC，12 次 Full GC）</td><td align="left">9232（47 次 GC，21 次 Full GC）</td></tr><tr><td align="left">4G</td><td align="left">8505（2 次 GC,0 次 Full GC）</td><td align="left">10228（2 次 GC,0 次 Full GC）</td><td align="left">11363（11 次 GC，0 次 Full GC）</td><td align="left">11809（14 次 GC，0 次 Full GC）</td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总体来看，当堆内存越大，GC 越不频繁，性能越好。当然，因为示例代码存在内存泄露的问题，只要时间够久，也总会 OOM 的。</p><p>至于并行 GC 在小内存的时候并没有表现出我想象中的性能优势，我的猜想是因为内存泄漏，每次 GC 其实都占用了不少时间，但其实越往后，能够回收的内存越少。因为 CMS 和 G1 对暂停时间有一定的控制，除非回收次数显著高于并行 GC，不然在示例代码中并行 GC 的优势并不明显。还有就是示例代码执行时间不够长，只有一秒钟，如果时间足够长，并行 GC 在吞吐量方面应该是有优势的。</p><p>在生产中，一般堆比较小的时候还是采用并行 GC 回收器，大内存的时候采用 G1 回收器，如果对延迟有特殊的要求，可以考虑 ZGC。</p><h2 id="JVM-线程堆栈数据分析"><a href="#JVM-线程堆栈数据分析" class="headerlink" title="JVM 线程堆栈数据分析"></a>JVM 线程堆栈数据分析</h2><h3 id="JVM-内部线程种类"><a href="#JVM-内部线程种类" class="headerlink" title="JVM 内部线程种类"></a>JVM 内部线程种类</h3><p>• VM 线程：单例的 VMThread 对象，负责执行 VM 操作，下文将对此进行讨论；</p><p>• 定时任务线程：单例的 WatcherThread 对象， 模拟在 VM 中执行定时操作的计时器中断；</p><p>• GC 线程：垃圾收集器中，用于支持并行和并发垃圾回收的线程；</p><p>• 编译器线程： 将字节码编译为本地机器代码；</p><p>• 信号分发线程：等待进程指示的信号，并将其分配给 Java 级别的信号处理方法。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ol><li><p>方法代码中被植入的安全点检测入口；</p></li><li><p>线程处于安全点状态：线程暂停执行，这个时候线程栈不再发生改变；</p></li><li><p>JVM 的安全点状态：所有线程都处于安全点状态。</p></li></ol><h3 id="JVM-支持多种方式来进行线程转储"><a href="#JVM-支持多种方式来进行线程转储" class="headerlink" title="JVM 支持多种方式来进行线程转储"></a>JVM 支持多种方式来进行线程转储</h3><ol><li><p>JDK 工具，包括：jstack 工具，jcmd 工具，jconsole, jvisualvm, Java Mission Control 等；</p></li><li><p>Shell 命令或者系统控制台，比如 Linux 的 kill -3,Windows 的 Ctrl + Break 等；</p></li><li><p>JMX 技术， 主要是使用 ThreadMxBean。</p></li></ol><h2 id="内存分析与相关工具"><a href="#内存分析与相关工具" class="headerlink" title="内存分析与相关工具"></a>内存分析与相关工具</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>一个对象具有 100 个属性，与 100 个对象每个具有 1 个属性，哪个占用的内存空间更大？</p><p>类比一百个箱子，每个箱子装一本书；一个箱子，装一百本书。</p><h3 id="一个-Java-对象占用多少内存？"><a href="#一个-Java-对象占用多少内存？" class="headerlink" title="一个 Java 对象占用多少内存？"></a>一个 Java 对象占用多少内存？</h3><p>可以使用 Instrumentation.getObjectSize() 方法来估算一个对象占用的内存空间。</p><p>JOL (Java Object Layout) 可以用来查看对象内存布局。</p><h3 id="对象头和对象引用"><a href="#对象头和对象引用" class="headerlink" title="对象头和对象引用"></a>对象头和对象引用</h3><p>在 64 位 JVM 中，对象头占据的空间是 12-byte(&#x3D;96bit&#x3D;64+32)，但是以 8 字节对齐，所以一个空类的实例至少占用 16 字节。</p><p>在 32 位 JVM 中，对象头占 8 个字节，以 4 的倍数对齐 (32&#x3D;4*8)。</p><p>所以 new 出来很多简单对象，甚至是 new Object()，都会占用不少内容哈。</p><p>通常在 32 位 JVM，以及内存小于 -Xmx32G 的 64 位 JVM 上（默认开启指针压缩），一个引用占的内存默认是 4 个字节。</p><p>因此，64 位 JVM 一般需要多消耗堆内存。</p><h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>包装类型比原生数据类型消耗的内存要多：</p><p>Integer：占用 16 字节 (8+4&#x3D;12+补齐），因为 int 部分占 4 个字节。所以使用 Integer 比原生类型 int 要多消耗 300% 的内存。</p><p>Long：一般占用 16 个字节 (8+8&#x3D;16)，当然，对象的实际大小由底层平台的内存对齐确定，具体由特定 CPU 平台的 JVM 实现决定。看起来一个 Long 类型的对象，比起原生类型 long 多占用了 8 个字节（也多消耗了 100%）。</p><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>在二维数组<code>int[dim1][dim2]</code> 中，每个嵌套的数组 int[dim2] 都是一个单独的 Object，会额外占用 16 字节的空间。当数组维度更大时，这种开销特别明显。</p><p><code>int[128][2]</code> 实例占用 3600 字节。而 int[256] 实例则只占用 1040 字节。里面的有效存储空间是一样的，3600 比起 1040 多了 246%的额外开销。在极端情况下，<code>byte[256][1]</code>，额外开销的比例是 19 倍！</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String 对象的空间随着内部字符数组的增长而增长。当然，String 类的对象有 24 个字节的额外开销。</p><p>对于 10 字符以内的非空 String，增加的开销比起有效载荷（每个字符 2 字节+ 4 个字节的 length），多占用了 100% 到 400% 的内存。</p><h4 id="对齐是绕不过去的问题"><a href="#对齐是绕不过去的问题" class="headerlink" title="对齐是绕不过去的问题"></a>对齐是绕不过去的问题</h4><p>我们可能会认为，一个 X 类的实例占用 17 字节的空间。但是由于需要对齐 (padding)，JVM 分配的内存是 8 字节的整数倍，所以占用的空间不是 17 字节，而是 24 字节。</p><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><h4 id="OutOfMemoryError-Java-heap-space"><a href="#OutOfMemoryError-Java-heap-space" class="headerlink" title="OutOfMemoryError: Java heap space"></a>OutOfMemoryError: Java heap space</h4><p>创建新的对象时，堆内存中的空间不足以存放新创建的对象</p><p>产生的原因，很多时候就类似于将 XXL 号的对象，往 S 号的 Java heap space 里面塞。其实清楚了原因，问题就很容易解决了：只要增加堆内存的大小，程序就能正常运行。</p><p>另外还有一些情况是由代码问题导致的：</p><p>• 超出预期的访问量&#x2F;数据量：应用系统设计时，一般是有“容量”定义的，部署这么多机器，用来处理一定流量的数据&#x2F;业务。如果访问量突然飙升，超过预期的阈值，类似于时间坐标系中针尖形状的图谱。那么在峰值所在的时间段，程序很可能就会卡死、并触发<code>java.lang.OutOfMemoryError: Java heap space</code>错误。</p><p>• 内存泄露 (Memory leak)：这也是一种经常出现的情形。由于代码中的某些隐蔽错误，导致系统占用的内存越来越多。如果某个方法&#x2F;某段代码存在内存泄漏，每执行一次，就会（有更多的垃圾对象）占用更多的内存。随着运行时间的推移，泄漏的对象耗光了堆中的所有内存，那么<code>java.lang.OutOfMemoryError: Java heap space</code> 错误就爆发了。</p><h4 id="OutOfMemoryError-PermGen-space-x2F-OutOfMemoryError-Metaspace"><a href="#OutOfMemoryError-PermGen-space-x2F-OutOfMemoryError-Metaspace" class="headerlink" title="OutOfMemoryError: PermGen space&#x2F;OutOfMemoryError: Metaspace"></a>OutOfMemoryError: PermGen space&#x2F;OutOfMemoryError: Metaspace</h4><p>java.lang.OutOfMemoryError: PermGen space 的主要原因，是加载到内存中的</p><p>class 数量太多或体积太大，超过了 PermGen 区的大小。</p><p>解决办法：增大 PermGen&#x2F;Metaspace</p><p>-XX:MaxPermSize&#x3D;512m</p><p>-XX:MaxMetaspaceSize&#x3D;512m</p><p>高版本 JVM 也可以：</p><p>-XX:+CMSClassUnloadingEnabled</p><h4 id="OutOfMemoryError-Unable-to-create-new-native-thread"><a href="#OutOfMemoryError-Unable-to-create-new-native-thread" class="headerlink" title="OutOfMemoryError: Unable to create new native thread"></a>OutOfMemoryError: Unable to create new native thread</h4><p>java.lang.OutOfMemoryError: Unable to create new native thread 错误是程序创建的线程数量已达到上限值的异常信息。</p><p>解决思路：</p><ol><li><p>调整系统参数 ulimit -a，echo 120000 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max</p></li><li><p>降低 xss 等参数</p></li><li><p>调整代码，改变线程创建和使用方式</p></li></ol><h3 id="内存-dump-分析工具"><a href="#内存-dump-分析工具" class="headerlink" title="内存 dump 分析工具"></a>内存 dump 分析工具</h3><ul><li>Eclipse MAT</li><li>jhat</li></ul><h2 id="JVM-问题分析调优经验"><a href="#JVM-问题分析调优经验" class="headerlink" title="JVM 问题分析调优经验"></a>JVM 问题分析调优经验</h2><h3 id="1-高分配速率"><a href="#1-高分配速率" class="headerlink" title="1. 高分配速率"></a>1. 高分配速率</h3><p>分配速率 (Allocation rate) 表示单位时间内分配的内存量。通常使用 MB&#x2F;sec 作为单位。上一次垃圾收集之后，与下一次 GC 开始之前的年轻代使用量，两者的差值除以时间，就是分配速率。</p><p>分配速率过高就会严重影响程序的性能，在 JVM 中可能会导致巨大的 GC 开销。</p><p>正常系统：分配速率较低 ~ 回收速率 -&gt; 健康</p><p>内存泄漏：分配速率持续大于回收速率 -&gt; OOM</p><p>性能劣化：分配速率较高 ~ 回收速率 -&gt; 亚健康</p><p>在某些情况下，只要增加年轻代的大小，即可降低分配速率过高所造成的影响。增加年轻代空间并不会降低分配速率，但是会减少 GC 的频率。如果每次 GC 后只有少量对象存活，minor GC 的暂停时间就不会明显增加。</p><h3 id="2-过早提升"><a href="#2-过早提升" class="headerlink" title="2. 过早提升"></a>2. 过早提升</h3><p>提升速率（promotion rate）用于衡量单位时间内从年轻代提升到老年代的数据量。一般使用 MB&#x2F;sec 作为单位，和分配速率类似。</p><p>JVM 会将长时间存活的对象从年轻代提升到老年代。根据分代假设，可能存在一种情况，老年代中不仅有存活时间长的对象，也可能有存活时间短的对象。这就是过早提升：对象存活时间还不够长的时候就被提升到了老年代。</p><p>major GC 不是为频繁回收而设计的，但 major GC 现在也要清理这些生命短暂的对象，就会导致 GC 暂停时间过长。这会严重影响系统的吞吐量。</p><p>GC 之前和之后的年轻代使用量以及堆内存使用量。这样就可以通过差值算出老年代的使用量。</p><p>和分配速率一样，提升速率也会影响 GC 暂停的频率。但分配速率主要影响 minor GC，而提升速率则影响 major GC 的频率。</p><p>有大量的对象提升，自然很快将老年代填满。老年代填充的越快，则 major GC 事件的频率就会越高。</p><p>一般来说过早提升的症状表现为以下形式：</p><ol><li><p>短时间内频繁地执行 full GC</p></li><li><p>每次 full GC 后老年代的使用率都很低，在 10-20%或以下</p></li><li><p>提升速率接近于分配速率</p></li></ol><p>解决这类问题，需要让年轻代存放得下暂存的数据，有两种简单的方法：</p><p>一是增加年轻代的大小，设置 JVM 启动参数，类似这样：-Xmx64m -XX:NewSize&#x3D;32m，程序在执行时，Full GC 的次数自然会减少很多，只会对 minor GC 的持续时间产生影响。</p><p>二是减少每次批处理的数量，也能得到类似的结果。</p><p>至于选用哪个方案，要根据业务需求决定。在某些情况下，业务逻辑不允许减少批处理的数量，那就只能增加堆内存，或者重新指定年轻代的大小。如果都不可行，就只能优化数据结构，减少内存消耗。</p><p>但总体目标依然是一致的：让临时数据能够在年轻代存放得下。</p><h2 id="GC-疑难情况问题分析"><a href="#GC-疑难情况问题分析" class="headerlink" title="GC 疑难情况问题分析"></a>GC 疑难情况问题分析</h2><p>1、查询业务日志，可以发现这类问题：请求压力大，波峰，遭遇降级，熔断等等，基础服务、外部 API 依赖。</p><p>2、查看系统资源和监控信息：</p><p>硬件信息、操作系统平台、系统架构；</p><p>排查 CPU 负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO 等待、IO 密集、丢数据、并发竞争等情况；</p><p>排查网络：流量打满，响应超时，无响应，DNS 问题，网络抖动，防火墙问题，物理故障，网络参数调整、超时、连接数。</p><p>3、查看性能指标，包括实时监控、历史数据。可以发现假死，卡顿、响应变慢等现象；</p><p>排查数据库，并发连接数、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查询</p><p>数据量、redo 日志、undo、binlog 日志、代理、工具 BUG。可以考虑的优化包括：集群、主备、只读实例、分片、分区；</p><p>大数据，中间件，JVM 参数。</p><p>4、排查系统日志，比如重启、崩溃、Kill。</p><p>5、APM，比如发现有些链路请求变慢等等。</p><p>6、排查应用系统</p><p>排查配置文件：启动参数配置、Spring 配置、JVM 监控参数、数据库参数、Log 参数、APM 配置、内存问题，比如是否存在内存泄漏，内存溢出、批处理导致的内存放大、GC 问题等等；</p><p>GC 问题，确定 GC 算法、确定 GC 的 KPI，GC 总耗时、GC 最大暂停时间、分析 GC 日志和监控指标：内存分配速度，分代提升速度，内存使用率等数据。适当时修改内存配置；</p><p>排查线程，理解线程状态、并发线程数，线程 Dump，锁资源、锁等待，死锁；</p><p>排查代码，比如安全漏洞、低效代码、算法优化、存储优化、架构调整、重构、解决业务代码 BUG、第三方库、XSS、CORS、正则；</p><p>单元测试：覆盖率、边界值、Mock 测试、集成测试。</p><p>7、排除资源竞争、坏邻居效应</p><p>8、疑难问题排查分析手段</p><p>DUMP 线程&#x2F;内存；</p><p>抽样分析&#x2F;调整代码、异步化、削峰填谷。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-相关总结（三）&quot;&gt;&lt;a href=&quot;#JVM-相关总结（三）&quot; class=&quot;headerlink&quot; title=&quot;JVM 相关总结（三）&quot;&gt;&lt;/a&gt;JVM 相关总结（三）&lt;/h1&gt;&lt;h2 id=&quot;GC-日志解读与分析&quot;&gt;&lt;a href=&quot;#GC-日志解读与分析&quot; class=&quot;headerlink&quot; title=&quot;GC 日志解读与分析&quot;&gt;&lt;/a&gt;GC 日志解读与分析&lt;/h2&gt;&lt;h3 id=&quot;示例代码&quot;&gt;&lt;a href=&quot;#示例代码&quot; class=&quot;headerlink&quot; title=&quot;示例代码&quot;&gt;&lt;/a&gt;示例代码&lt;/h3&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://blog.jiangchen.tech/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM 相关总结（二）</title>
    <link href="https://blog.jiangchen.tech/2021/04/49bfdd2b.html"/>
    <id>https://blog.jiangchen.tech/2021/04/49bfdd2b.html</id>
    <published>2021-04-13T16:35:16.000Z</published>
    <updated>2021-04-13T16:35:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-相关总结（二）"><a href="#JVM-相关总结（二）" class="headerlink" title="JVM 相关总结（二）"></a>JVM 相关总结（二）</h1><h2 id="GC-的背景与一般原理"><a href="#GC-的背景与一般原理" class="headerlink" title="GC 的背景与一般原理"></a>GC 的背景与一般原理</h2><h3 id="为什么会有-GC"><a href="#为什么会有-GC" class="headerlink" title="为什么会有 GC"></a>为什么会有 GC</h3><p>本质上是因为内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="引用计数（Reference-Counting）"><a href="#引用计数（Reference-Counting）" class="headerlink" title="引用计数（Reference Counting）"></a>引用计数（Reference Counting）</h4><p>可能导致循环依赖的问题</p><h4 id="可达性分析（Reachability-Analysis）"><a href="#可达性分析（Reachability-Analysis）" class="headerlink" title="可达性分析（Reachability Analysis）"></a>可达性分析（Reachability Analysis）</h4><p>也可叫引用跟踪，通过一系列“GC Roots”根据引用关系向下搜索</p><p>可以作为 GC Roots 的对象</p><ol><li>当前正在执行的方法里的局部变量和输入参数</li><li>活动线程（Active threads）</li><li>所有类的静态字段（static field）</li><li>JNI 引用</li></ol><p>此阶段暂停的时间，与堆内存大小，对象的总数没有直接关系，而是由存活对象（alive objects）的数量来决定。所以增加堆内存的大小并不会直接影响标记阶段占用的时间。</p><span id="more"></span><p><img src="https://img.jiangchen.tech/image-20210408221111317.png" alt="image-20210408221111317"></p><h4 id="怎样才能标记和清除上百万对象？"><a href="#怎样才能标记和清除上百万对象？" class="headerlink" title="怎样才能标记和清除上百万对象？"></a>怎样才能标记和清除上百万对象？</h4><p>答案是 STW（Stop The World），让全世界停下来。</p><h4 id="分代假设"><a href="#分代假设" class="headerlink" title="分代假设"></a>分代假设</h4><p>大部分新生对象很快无用；存活较长时间的对象，可能存活更长时间。</p><p>内存池划分：不同类型对象不同区域，不同策略处理。</p><h4 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h4><ul><li>清除算法（标记-清除算法 Mark-Sweep）</li><li>整理算法（标记-清除-整理算法 Mark-Sweep-Compact）</li><li>复制算法（标记-复制算法 Mark-Copy）</li></ul><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="串行-GC（Serial-GC）-x2F-ParNewGC"><a href="#串行-GC（Serial-GC）-x2F-ParNewGC" class="headerlink" title="串行 GC（Serial GC）&#x2F;ParNewGC"></a>串行 GC（Serial GC）&#x2F;ParNewGC</h3><p>-XX:+UseSerialGC 配置串行 GC</p><p>串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除-整理）算法。</p><p>两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。</p><p>因此这种 GC 算法不能充分利用多核 CPU。不管有多少 CPU 内核，JVM 在垃圾收集时都只能使用单个核心。</p><p>CPU 利用率高，暂停时间长。简单粗暴，就像老式的电脑，动不动就卡死。</p><p>该选项只适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用。</p><p>-XX:+USeParNewGC 改进版本的 Serial GC，可以配合 CMS 使用。</p><h3 id="并行-GC（Parallel-GC）"><a href="#并行-GC（Parallel-GC）" class="headerlink" title="并行 GC（Parallel GC）"></a>并行 GC（Parallel GC）</h3><blockquote><p>-XX:+UseParallelGC<br>-XX:+UseParallelOldGC<br>-XX:+UseParallelGC -XX:+UseParallelOldGC</p></blockquote><p>年轻代和老年代的垃圾回收都会触发 STW 事件。</p><p>在年轻代使用 标记-复制（mark-copy）算法，在老年代使用 标记-清除-整理（mark-sweep-compact）算法。</p><p>-XX:ParallelGCThreads&#x3D;N 来指定 GC 线程数， 其默认值为 CPU 核心数。</p><p>并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量：<br>• 在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；<br>• 在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。</p><h3 id="CMS-GC（Mostly-Concurrent-Mark-and-Sweep-Garbage-Collector）"><a href="#CMS-GC（Mostly-Concurrent-Mark-and-Sweep-Garbage-Collector）" class="headerlink" title="CMS GC（Mostly Concurrent Mark and Sweep Garbage Collector）"></a>CMS GC（Mostly Concurrent Mark and Sweep Garbage Collector）</h3><p>-XX:+UseConcMarkSweepGC</p><p>其对年轻代采用并行 STW 方式的 mark-copy （标记-复制）算法，对老年代主要使用并发 mark-sweep （标记-清除）算法。</p><p>CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：</p><ol><li>不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。</li><li>在 mark-and-sweep （标记-清除） 阶段的大部分工作和应用线程一起并发执行。<br>也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1&#x2F;4。</li></ol><p>如果服务器是多核 CPU，并且主要调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是个很明智的选择。进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。</p><p>好处：暂停时间比并行 GC 短；</p><p>缺点：复杂；吞吐量没有并行 GC 高；</p><h4 id="并行-Parallel-与并发-Concurrent-的区别？"><a href="#并行-Parallel-与并发-Concurrent-的区别？" class="headerlink" title="并行 Parallel 与并发 Concurrent 的区别？"></a>并行 Parallel 与并发 Concurrent 的区别？</h4><p>在 JVM 语言环境里面，并发是指，一部分线程做业务，一部分线程做 GC；并行是指处理 GC 的时候是多线程的，跟单线程区别。</p><p>CMS 跟 Serial，ParNew 都是老的一套架构，一般配合使用。</p><h4 id="CMS-的六个阶段"><a href="#CMS-的六个阶段" class="headerlink" title="CMS 的六个阶段"></a>CMS 的六个阶段</h4><p><strong>阶段 1: Initial Mark（初始标记）- STW</strong></p><p>这个阶段伴随着 STW 暂停。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象（老年代单独回收）。</p><p><strong>阶段 2: Concurrent Mark（并发标记）</strong></p><p>在此阶段，CMS GC 遍历老年代，标记所有的存活对象，从前一阶段 “Initial Mark” 找到的根对象开始算起。 “并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。</p><p><strong>阶段 3: Concurrent Preclean（并发预清理）</strong></p><p>此阶段同样是与应用线程并发执行的，不需要停止应用线程。 因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的 卡片标记（Card Marking）。</p><p><strong>阶段 4: Final Remark（最终标记）- STW</strong></p><p>最终标记阶段是此次 GC 事件中的第二次（也是最后一次）STW 停顿。本阶段的目标是完成老年代中所有存活对象的标记。因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度。所以需要一次 STW 暂停来处理各种复杂的情况。通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。</p><p><strong>阶段 5: Concurrent Sweep（并发清除）</strong></p><p>此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此阶段删除不再使用的对象，并回收他们占用的内存空间。</p><p><strong>阶段 6: Concurrent Reset（并发重置）</strong></p><p>此阶段与应用程序并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备。</p><h4 id="CMS-总结"><a href="#CMS-总结" class="headerlink" title="CMS 总结"></a>CMS 总结</h4><p>CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程。 当然，CMS 也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下 GC 会造成不可预测的暂停时间，特别是堆内存较大的情况下。</p><h3 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h3><p>G1 的全称是 Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。</p><p>G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。</p><p>事实上，G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。为了达成可预期停顿时间的指标，G1 GC 有一些独特的实现。</p><p>首先，堆不再分成年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象的小块堆区域 (smaller heap regions)。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代。</p><p>-XX:+UseG1GC -XX:MaxGCPauseMillis&#x3D;50</p><p>这样划分之后，使得 G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理：每次只处理一部分内存块，称为此次 GC 的回收集 (collection set)。每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。</p><p>G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集。这也是 G1 名称的由来。</p><h4 id="G1-GC-配置参数"><a href="#G1-GC-配置参数" class="headerlink" title="G1 GC 配置参数"></a>G1 GC 配置参数</h4><p>-XX:+UseG1GC：启用 G1 GC；</p><p>-XX:G1NewSizePercent：初始年轻代占整个 Java Heap 的大小，默认值为 5%；</p><p>-XX:G1MaxNewSizePercent：最大年轻代占整个 Java Heap 的大小，默认值为 60%；</p><p>-XX:G1HeapRegionSize：设置每个 Region 的大小，单位 MB，需要为 1，2，4，8，16，32 中的某个值，默认是堆内存的 1&#x2F;2000。如果这个值设置比较大，那么大对象就可以进入 Region 了。</p><p>-XX:ConcGCThreads：与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1&#x2F;4，减少这个参数的数值可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回收机制耗时加长。</p><p>-XX:+InitiatingHeapOccupancyPercent（简称 IHOP）：G1 内部并行回收循环启动的阈值，默认为 Java Heap 的 45%。这个可以理解为老年代使用大于等于 45% 的时候，JVM 会启动垃圾回收。这个值非常重要，它决定了在什么时间启动老年代的并行回收。</p><p>-XX:G1HeapWastePercent：G1 停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中的对象，但是如果下降到了 5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以遗留少量的下次处理，这样也降低了单次消耗的时间。</p><p>-XX:G1MixedGCCountTarget：设置并行循环之后需要有多少个混合 GC 启动，默认值是 8 个。老年代 Regions 的回收时间通常比年轻代的收集时间要长一些。所以如果混合收集器比较多，可以允许 G1 延长老年代的收集时间。</p><p>-XX:+G1PrintRegionLivenessInfo：这个参数需要和 -XX:+UnlockDiagnosticVMOptions 配合启动，打印 JVM 的调试信息，每个 Region 里的对象存活信息。</p><p>-XX:G1ReservePercent：G1 为了保留一些空间用于年代之间的提升，默认值是堆空间的 10%。因为大量执行回收的地方在年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、比较多的大对象存活，这里需要保留一些内存。</p><p>-XX:+G1SummarizeRSetStats：这也是一个 VM 的调试信息。如果启用，会在 VM 退出的时候打印出 Rsets 的详细总结信息。如果启用 -XX:G1SummaryRSetStatsPeriod 参数，就会阶段性地打印 Rsets 信息。</p><p>-XX:+G1TraceConcRefinement：这个也是一个 VM 的调试信息，如果启用，并行回收阶段的日志就会被详细打印出来。</p><p>-XX:+GCTimeRatio：这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9，跟新生代内存的分配比例一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100&#x2F;（1+GCTimeRatio）。这样如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面。Parallel GC 的默认值是 99，表示 1% 的时间被用在 GC 上面，这是因为 Parallel GC 贯穿整个 GC，而 G1 则根据 Region 来进行划分，不需要全局性扫描整个内存堆。</p><p>-XX:+UseStringDeduplication：手动开启 Java String 对象的去重工作，这个是 JDK8u20 版本之后新增的参数，主要用于相同 String 避免重复申请内存，节约 Region 的使用。</p><p>-XX:MaxGCPauseMills：预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是 200 毫秒，G1 会尽量保证控制在<br>这个范围内。</p><h4 id="G1-GC-的处理步骤"><a href="#G1-GC-的处理步骤" class="headerlink" title="G1 GC 的处理步骤"></a>G1 GC 的处理步骤</h4><p><strong>1、年轻代模式转移暂停（Evacuation Pause）</strong></p><p>G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区。</p><p>拷贝的过程称为转移（Evacuation)，这和前面介绍的其他年轻代收集器是一样的工作原理。</p><p><strong>2、并发标记（Concurrent Marking）</strong></p><p>同时我们也可以看到，G1 GC 的很多概念建立在 CMS 的基础上，所以下面的内容需要对 CMS 有一定的理解。</p><p>G1 并发标记的过程与 CMS 基本上是一样的。G1 的并发标记通过 Snapshot-At-The-Beginning（起始快照）的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。</p><p>这些信息在接下来的阶段会用来执行老年代区域的垃圾收集。</p><p>有两种情况是可以完全并发执行的：</p><ol><li>如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾；</li><li>在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块。</li></ol><p>当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45%，但也可以通过 JVM 参数 InitiatingHeapOccupancyPercent 来设置。和 CMS 一样，G1 的并发标记也是由多个阶段组成，其中一些阶段是完全并发的，还有一些阶段则会暂停应用线程。</p><p><strong>3、转移暂停：混合模式（Evacuation Pause (mixed)）</strong></p><p>并发标记完成之后，G1 将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部分老年代区域也加入到 回收集 中。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。</p><p>因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停。</p><p>具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实时性能指标，存活性，以及在并发标记期间收集的 GC 效率等数据，外加一些可配置的 JVM 选项。混合收集的过程，很大程度上和前面的 fully-young gc 是一样的。</p><h4 id="G1-GC-的注意事项"><a href="#G1-GC-的注意事项" class="headerlink" title="G1 GC 的注意事项"></a>G1 GC 的注意事项</h4><p>特别需要注意的是，某些情况下 G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的。</p><p><strong>1. 并发模式失败</strong></p><p>G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。解决办法：增加堆大小，或者调整周期（例如增加线程数 -XX:ConcGCThreads 等）。</p><p><strong>2. 晋升失败</strong></p><p>没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC(to-space exhausted&#x2F;to-space overflow）。</p><p>解决办法：</p><ol><li><p>增加 –XX：G1ReservePercent 选项的值（并相应增加总的堆大小）增加预留内存量。</p></li><li><p>通过减少 –XX：InitiatingHeapOccupancyPercent 提前启动标记周期。</p></li><li><p>也可以通过增加 –XX：ConcGCThreads 选项的值来增加并行标记线程的数目。</p></li></ol><p><strong>3. 巨型对象分配失败</strong></p><p>当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间。</p><p>解决办法：增加内存或者增大 -XX:G1HeapRegionSize</p><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g</p><p>ZGC 最主要的特点包括：</p><ol><li>GC 最大停顿时间不超过 10ms</li><li>堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆内存（JDK13 升至 16TB）</li><li>与 G1 相比，应用吞吐量下降不超过 15%</li><li>当前只支持 Linux&#x2F;x64 位平台，JDK15 后支持 MacOS 和 Windows 系统</li></ol><h3 id="各个-GC-对比"><a href="#各个-GC-对比" class="headerlink" title="各个 GC 对比"></a>各个 GC 对比</h3><p>如图：</p><p><img src="https://img.jiangchen.tech/image-20210414002137322.png" alt="image-20210414002137322"></p><h3 id="常用-GC-组合"><a href="#常用-GC-组合" class="headerlink" title="常用 GC 组合"></a>常用 GC 组合</h3><p>常用的组合为：</p><ol><li>Serial+Serial Old 实现单线程的低延迟垃圾回收机制；</li><li>ParNew+CMS，实现多线程的低延迟垃圾回收机制；</li><li>Parallel Scavenge 和 Parallel Scavenge Old，实现多线程的高吞吐量垃圾回收机制；</li></ol><p><img src="https://img.jiangchen.tech/image-20210414002330526.png" alt="image-20210414002330526"></p><h3 id="GC-如何选择"><a href="#GC-如何选择" class="headerlink" title="GC 如何选择"></a>GC 如何选择</h3><p>选择正确的 GC 算法，唯一可行的方式就是去尝试，一般性的指导原则：</p><ol><li>如果系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC；</li><li>如果系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC；</li><li>如果系统内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC。</li></ol><p>对于内存大小的考量：</p><ol><li>一般 4G 以上，算是比较大，用 G1 的性价比较高。</li><li>一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。</li></ol><h3 id="GC-总结"><a href="#GC-总结" class="headerlink" title="GC 总结"></a>GC 总结</h3><p>到目前为止，我们一共了解了 Java 目前支持的所有 GC 算法，一共有 7 类：</p><ol><li>串行 GC（Serial GC）: 单线程执行，应用需要暂停；</li><li>并行 GC（ParNew、Parallel Scavenge、Parallel Old）: 多线程并行地执行垃圾回收，关注与高吞吐；</li><li>CMS（Concurrent Mark-Sweep）: 多线程并发标记和清除，关注与降低延迟；</li><li>G1（G First）: 通过划分多个内存区域做增量整理和回收，进一步降低延迟；</li><li>ZGC（Z Garbage Collector）: 通过着色指针和读屏障，实现几乎全部的并发执行，几毫秒级别的延迟，线性可扩展；</li><li>Epsilon: 实验性的 GC，供性能分析使用；</li><li>Shenandoah: G1 的改进版本，跟 ZGC 类似。</li></ol><p>可以看出 GC 算法和实现的演进路线：</p><ol><li>串行 -&gt; 并行：重复利用多核 CPU 的优势，大幅降低 GC 暂停时间，提升吞吐量。</li><li>并行 -&gt; 并发： 不只开多个 GC 线程并行回收，还将 GC 操作拆分为多个步骤，让很多繁重的任务和应用线程一起并发执行，减少了单次 GC 暂停持续的时间，这能有效降低业务系统的延迟。</li><li>CMS -&gt; G1： G1 可以说是在 CMS 基础上进行迭代和优化开发出来的，划分为多个小堆块进行增量回收，这样就更进一步地降低了单次 GC 暂停的时间</li><li>G1 -&gt; ZGC:：ZGC 号称无停顿垃圾收集器，这又是一次极大的改进。ZGC 和 G1 有一些相似的地方，但是底层的算法和思想又有了全新的突破。</li></ol><p><strong>“脱离场景谈性能都是耍流氓”。</strong></p><p>目前绝大部分 Java 应用系统，堆内存并不大比如 2G-4G 以内，而且对 10ms 这种低延迟的 GC 暂停不敏感，也就是说处理一个业务步骤，大概几百毫秒都是可以接受的，GC 暂停 100ms 还是 10ms 没多大区别。另一方面，系统的吞吐量反而往往是我们追求的重点，这时候就需要考虑采用并行 GC。</p><p>如果堆内存再大一些，可以考虑 G1 GC。如果内存非常大（比如超过 16G，甚至是 64G、128G），或者是对延迟非常敏感（比如高频量化交易系统），就需要考虑使用新 GC（ZGC&#x2F;Shenandoah）。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-相关总结（二）&quot;&gt;&lt;a href=&quot;#JVM-相关总结（二）&quot; class=&quot;headerlink&quot; title=&quot;JVM 相关总结（二）&quot;&gt;&lt;/a&gt;JVM 相关总结（二）&lt;/h1&gt;&lt;h2 id=&quot;GC-的背景与一般原理&quot;&gt;&lt;a href=&quot;#GC-的背景与一般原理&quot; class=&quot;headerlink&quot; title=&quot;GC 的背景与一般原理&quot;&gt;&lt;/a&gt;GC 的背景与一般原理&lt;/h2&gt;&lt;h3 id=&quot;为什么会有-GC&quot;&gt;&lt;a href=&quot;#为什么会有-GC&quot; class=&quot;headerlink&quot; title=&quot;为什么会有 GC&quot;&gt;&lt;/a&gt;为什么会有 GC&lt;/h3&gt;&lt;p&gt;本质上是因为内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;h4 id=&quot;引用计数（Reference-Counting）&quot;&gt;&lt;a href=&quot;#引用计数（Reference-Counting）&quot; class=&quot;headerlink&quot; title=&quot;引用计数（Reference Counting）&quot;&gt;&lt;/a&gt;引用计数（Reference Counting）&lt;/h4&gt;&lt;p&gt;可能导致循环依赖的问题&lt;/p&gt;
&lt;h4 id=&quot;可达性分析（Reachability-Analysis）&quot;&gt;&lt;a href=&quot;#可达性分析（Reachability-Analysis）&quot; class=&quot;headerlink&quot; title=&quot;可达性分析（Reachability Analysis）&quot;&gt;&lt;/a&gt;可达性分析（Reachability Analysis）&lt;/h4&gt;&lt;p&gt;也可叫引用跟踪，通过一系列“GC Roots”根据引用关系向下搜索&lt;/p&gt;
&lt;p&gt;可以作为 GC Roots 的对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前正在执行的方法里的局部变量和输入参数&lt;/li&gt;
&lt;li&gt;活动线程（Active threads）&lt;/li&gt;
&lt;li&gt;所有类的静态字段（static field）&lt;/li&gt;
&lt;li&gt;JNI 引用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此阶段暂停的时间，与堆内存大小，对象的总数没有直接关系，而是由存活对象（alive objects）的数量来决定。所以增加堆内存的大小并不会直接影响标记阶段占用的时间。&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://blog.jiangchen.tech/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM 相关总结（一）</title>
    <link href="https://blog.jiangchen.tech/2021/04/197e5454.html"/>
    <id>https://blog.jiangchen.tech/2021/04/197e5454.html</id>
    <published>2021-04-12T16:30:50.000Z</published>
    <updated>2021-04-12T16:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-相关总结（一）"><a href="#JVM-相关总结（一）" class="headerlink" title="JVM 相关总结（一）"></a>JVM 相关总结（一）</h1><h2 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h2><h3 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h3><p><code>Java bytecode</code> 由单字节 (byte) 的指令组成，理论上最多支持 256（2^8&#x3D;256）个操作码。实际上 Java 只使用了 200 左右的操作码，还有一些操作码则保留给调试操作。</p><p>根据指令的性质，主要分为四个大类：</p><ol><li>栈操作指令，包括与局部变量交互的指令</li><li>程序流控制指令</li><li>对象操作指令，包括方法调用指令</li><li>算数运算以及类型转换指令<span id="more"></span><h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h3></li></ol><p>编译：<code>javac Hello.java</code></p><p>查看字节码：<code>javap -c Hello</code></p><p>进一步：<code>javap -c -verbose Hello</code></p><h3 id="字节码的运行时结构"><a href="#字节码的运行时结构" class="headerlink" title="字节码的运行时结构"></a>字节码的运行时结构</h3><p>JVM 是一台基于栈的计算机器。每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储栈帧（Frame）。</p><p>每一次方法调用，JVM 都会自动创建一个栈帧。</p><p>栈帧由操作数栈，局部变量数组以及一个 Class 引用组成。Class 引用指向当前方法在运行时常量池中对应的 Class。</p><h2 id="JVM-类加载器"><a href="#JVM-类加载器" class="headerlink" title="JVM 类加载器"></a>JVM 类加载器</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><ol><li>加载（Loading）：找 Class 文件</li><li>验证（Verification）：验证格式、依赖</li><li>准备（Preparation）：静态字段、方法表</li><li>解析（Resolution）：符号解析为引用</li><li>初始化（Initialization）：构造器、静态变量赋值、静态代码块</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><h3 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h3><ol><li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；</li><li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li><li>使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li></ol><h3 id="不会初始化（可能会加载）"><a href="#不会初始化（可能会加载）" class="headerlink" title="不会初始化（可能会加载）"></a>不会初始化（可能会加载）</h3><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li><li>定义对象数组，不会触发该类的初始化。</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li><li>通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化。</li><li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName（“jvm.Hello”）默认会加载 Hello 类。</li><li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是不初始化）。</li></ol><h3 id="三类加载器"><a href="#三类加载器" class="headerlink" title="三类加载器"></a>三类加载器</h3><ol><li>启动类加载器（BootstrapClassLoader）</li><li>扩展类加载器（ExtClassLoader）</li><li>应用类加载器（AppClassLoader）</li></ol><h4 id="加载器特点"><a href="#加载器特点" class="headerlink" title="加载器特点"></a>加载器特点</h4><ol><li>双亲委托</li><li>负责依赖</li><li>缓存加载</li></ol><h4 id="为啥双亲委托？"><a href="#为啥双亲委托？" class="headerlink" title="为啥双亲委托？"></a>为啥双亲委托？</h4><ol><li>沙箱安全机制：防止核心库被随意篡改</li><li>避免类的重复加载：当父加载器已经加载该类，不需要子加载器再加载一次</li></ol><h3 id="添加引用类的几种方式"><a href="#添加引用类的几种方式" class="headerlink" title="添加引用类的几种方式"></a>添加引用类的几种方式</h3><p>1、放到 JDK 的 lib&#x2F;ext 下，或者-Djava.ext.dirs<br>2、 java –cp&#x2F;classpath 或者 class 文件放到当前路径<br>3、自定义 ClassLoader 加载<br>4、拿到当前执行类的 ClassLoader，反射调用 addUrl 方法添加 Jar 或路径 (JDK9 无效）</p><h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h2><h3 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h3><p>每个线程都只能访问自己的线程栈。每个线程都不能访问（看不见）其他线程的局部变量。</p><p>所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。</p><p>线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。</p><p>堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。 其中也涵盖了包装类型（例如 Byte，Integer，Long 等）。</p><p>不管是创建一个对象并将其赋值给局部变量， 还是赋值给另一个对象的成员变量， 创建的对象都会被保存到堆内存中。</p><p>如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。</p><p>如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。</p><p>对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数值，还是 对象引用。</p><p>类的静态变量则和类定义一样都保存在堆中。</p><h3 id="JVM-内存整体结构"><a href="#JVM-内存整体结构" class="headerlink" title="JVM 内存整体结构"></a>JVM 内存整体结构</h3><p>如图所示：</p><p><img src="https://img.jiangchen.tech/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM 内存结构"></p><h4 id="Tip：最大堆内存设置"><a href="#Tip：最大堆内存设置" class="headerlink" title="Tip：最大堆内存设置"></a>Tip：最大堆内存设置</h4><p>最大堆内存设置一般为宿主机或者容器可用内存的 60-70%为好，因为还有非堆、堆外内存等其他需要使用内存的区域，不然可能导致 OOM 等问题。</p><h3 id="CPU-与内存行为"><a href="#CPU-与内存行为" class="headerlink" title="CPU 与内存行为"></a>CPU 与内存行为</h3><ul><li>CPU 乱序执行</li><li>volatile 关键字</li><li>原子性操作</li><li>内存屏障</li></ul><h4 id="什么是-JMM？"><a href="#什么是-JMM？" class="headerlink" title="什么是 JMM？"></a>什么是 JMM？</h4><p>JMM 规范明确定义了不同的线程之间，通过哪些方式，在什么时候可以看见其它线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了 Java 并发程序真正的跨平台。</p><h2 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a>JVM 启动参数</h2><h3 id="JVM-启动参数简介"><a href="#JVM-启动参数简介" class="headerlink" title="JVM 启动参数简介"></a>JVM 启动参数简介</h3><p>以 - 开头为标准参数，所有的 JVM 都要实现这些参数，并且向后兼容。（如 -server）</p><p>-D 设置系统属性（如 -Dfile.encoding&#x3D;UTF-8）</p><p>-X 非标准参数，基本都是传给 JVM 的，默认 JVM 实现这些参数的功能，但是并不保证所有 JVM 实现都满足，切不保证向后兼容。可以使用<code>java -X</code>命令来查看当前 JVM 支持的非标准参数。（如 -Xmx8g）</p><p>–XX：开头为非稳定参数，专门用于控制 JVM 的行为，跟具体的 JVM 实现有关，随时可能会在下个版本取消。</p><p>-XX：+-Flags 形式，+- 是对布尔值进行开关。（如 -XX:+UseG1GC，加减开关，+表示打开，-表示关闭）</p><p>-XX：key&#x3D;value 形式，指定某个选项的值。（如 -XX:MaxPermSize&#x3D;256m）</p><h3 id="JVM-启动参数类型"><a href="#JVM-启动参数类型" class="headerlink" title="JVM 启动参数类型"></a>JVM 启动参数类型</h3><ul><li>系统属性参数</li><li>运行模式参数</li><li>堆内存设置参数</li><li>GC 设置参数</li><li>分析诊断参数</li><li>JavaAgent 参数</li></ul><h2 id="JDK-内置命令行工具"><a href="#JDK-内置命令行工具" class="headerlink" title="JDK 内置命令行工具"></a>JDK 内置命令行工具</h2><h3 id="JVM-命令行工具"><a href="#JVM-命令行工具" class="headerlink" title="JVM 命令行工具"></a>JVM 命令行工具</h3><ul><li>java：Java 应用的启动程序</li><li>javac：JDK 内置的编译工具</li><li>javap：反编译 class 文件的工具</li><li>javadoc：根据 Java 代码和标准注释，自动生成相关的 API 说明文档</li><li>javah：JNI 开发时，根据 java 代码生成需要的 .h 文件</li><li>extcheck：检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用</li><li>jdb：Java Debugger ; 可以调试本地和远端程序，属于 JPDA 中的一个 demo 实现，供其他调试器参考。开发时很少使用</li><li>jdeps：探测 class 或 jar 包需要的依赖</li><li>jar：打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件，只是后缀不同。使用时按顺序对应好选项和参数即可</li><li>keytool：安全证书和密钥的管理工具（支持生成、导入、导出等操作）</li><li>jarsigner：JAR 文件签名和验证工具</li><li>policytool：实际上这是一款图形界面工具，管理本机的 Java 安全策略</li><li>jps&#x2F;jinfo：查看 java 进程</li><li>jstat：查看 JVM 内部 gc 相关信息</li><li>jmap：查看 heap 或类占用空间统计</li><li>jstack：查看线程信息</li><li>jcmd：执行 JVM 相关分析命令（整合命令）</li><li>jrunscript&#x2F;jjs：执行 js 命令</li></ul><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jstat -options</span></span><br><span class="line">-class 类加载 (Class loader) 信息统计</span><br><span class="line">-compiler JIT 即时编译器相关的统计信息</span><br><span class="line">-gc GC 相关的堆内存信息，用法：jstat -gc -h 10 -t 864 1s 20</span><br><span class="line">-gccapacity 各个内存池分代空间的容量</span><br><span class="line">-gccause 看上次 GC, 本次 GC（如果正在 GC 中）的原因，其他输出和 -gcutil 选项一致</span><br><span class="line">-gcnew 年轻代的统计信息（New = Young = Eden + S0 + S1）</span><br><span class="line">-gcnewcapacity 年轻代空间大小统计</span><br><span class="line">-gcold 老年代和元数据区的行为统计</span><br><span class="line">-gcoldcapacity old 空间大小统计</span><br><span class="line">-gcmetacapacity meta 区大小统计</span><br><span class="line">-gcutil GC 相关区域的使用率（utilization）统计</span><br><span class="line">-printcompilation 打印 JVM 编译统计信息</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil pid 1000 1000</span><br></pre></td></tr></table></figure><p>每隔 1 秒，打印一千次</p><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>常用选项就 3 个：</p><p>-heap 打印堆内存（&#x2F;内存池）的配置和使用信息</p><p>-histo 看哪些类占用的空间最多，直方图</p><p>-dump:format&#x3D;b,file&#x3D;xxxx.hprof Dump 堆内存</p><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid</span><br><span class="line">jmap -histo pid</span><br><span class="line">jmap -dump:format=b,file=3826.hprof 3826</span><br></pre></td></tr></table></figure><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>-F 强制执行 thread dump. 可在 Java 进程卡死（hung 住）时使用，此选项可能需要系统权限。</p><p>-m 混合模式 (mixed mode), 将 Java 帧和 native 帧一起输出，此选项可能需要系统权限。</p><p>-l 长列表模式。将线程相关的 locks 信息一起输出，比如持有的锁，等待的锁。</p><p>如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid -l</span><br></pre></td></tr></table></figure><h3 id="JVM-图形化工具"><a href="#JVM-图形化工具" class="headerlink" title="JVM 图形化工具"></a>JVM 图形化工具</h3><ul><li>jconsole</li><li>jvisualvm</li><li>VisualGC</li><li>jmc</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-相关总结（一）&quot;&gt;&lt;a href=&quot;#JVM-相关总结（一）&quot; class=&quot;headerlink&quot; title=&quot;JVM 相关总结（一）&quot;&gt;&lt;/a&gt;JVM 相关总结（一）&lt;/h1&gt;&lt;h2 id=&quot;Java-字节码&quot;&gt;&lt;a href=&quot;#Java-字节码&quot; class=&quot;headerlink&quot; title=&quot;Java 字节码&quot;&gt;&lt;/a&gt;Java 字节码&lt;/h2&gt;&lt;h3 id=&quot;什么是字节码？&quot;&gt;&lt;a href=&quot;#什么是字节码？&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码？&quot;&gt;&lt;/a&gt;什么是字节码？&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Java bytecode&lt;/code&gt; 由单字节 (byte) 的指令组成，理论上最多支持 256（2^8&amp;#x3D;256）个操作码。实际上 Java 只使用了 200 左右的操作码，还有一些操作码则保留给调试操作。&lt;/p&gt;
&lt;p&gt;根据指令的性质，主要分为四个大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;栈操作指令，包括与局部变量交互的指令&lt;/li&gt;
&lt;li&gt;程序流控制指令&lt;/li&gt;
&lt;li&gt;对象操作指令，包括方法调用指令&lt;/li&gt;
&lt;li&gt;算数运算以及类型转换指令</summary>
    
    
    
    <category term="JVM" scheme="https://blog.jiangchen.tech/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 vercel 部署博客</title>
    <link href="https://blog.jiangchen.tech/2021/03/a305badf.html"/>
    <id>https://blog.jiangchen.tech/2021/03/a305badf.html</id>
    <published>2021-03-08T03:32:11.000Z</published>
    <updated>2021-03-08T03:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-vercel-部署博客"><a href="#使用-vercel-部署博客" class="headerlink" title="使用 vercel 部署博客"></a>使用 vercel 部署博客</h3><p>使用 GitHub Pages 部署博客之后碰到一个问题，seo 相关的。</p><p>网址上报 google 之后，很快能被谷歌搜索到，但是在百度上报纸后，发现百度报错说爬取不到资源。上网查了一下，看到说的是：</p><blockquote><p>2015 年，因为一些不能细说的原因，Github 开始拒绝百度爬虫的访问，直接返回 403。</p></blockquote><span id="more"></span><blockquote><p>官方给出原因是，百度爬虫爬得太狠，影响了 Github Page 服务的正常使用。这就导致了，但凡在 Github Page 搭建的个人博客，都无法被百度收录。</p></blockquote><p>然后发现文中提到的一个网站托管服务，<code>vercel</code>。</p><p>简单来说，就是授权 vercel 读取你的 github 仓库，然后基于博客源代码，vercel 自行构建发布，还支持 https 等功能，也就是说，只需要将 webhook 添加到 github 仓库，就能实现当我们推送博客文章时，vercel 就帮我们自动构建部署的功能。</p><p>关键这种方式部署的网站能够同时被百度跟谷歌搜索到。</p><p>部署的项目也能绑定自定义域名，也就是说在域名解析里面，配置一下，就能通过自定义域名访问自己在 vercel 部署的博客了。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://zpjiang.me/2020/01/15/let-baidu-index-github-page/">解决百度爬虫无法爬取 Github Pages 个人博客的问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;使用-vercel-部署博客&quot;&gt;&lt;a href=&quot;#使用-vercel-部署博客&quot; class=&quot;headerlink&quot; title=&quot;使用 vercel 部署博客&quot;&gt;&lt;/a&gt;使用 vercel 部署博客&lt;/h3&gt;&lt;p&gt;使用 GitHub Pages 部署博客之后碰到一个问题，seo 相关的。&lt;/p&gt;
&lt;p&gt;网址上报 google 之后，很快能被谷歌搜索到，但是在百度上报纸后，发现百度报错说爬取不到资源。上网查了一下，看到说的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2015 年，因为一些不能细说的原因，Github 开始拒绝百度爬虫的访问，直接返回 403。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="博客" scheme="https://blog.jiangchen.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 GitHub Actions 实现 Hexo 博客的 CICD</title>
    <link href="https://blog.jiangchen.tech/2021/03/710a5ed8.html"/>
    <id>https://blog.jiangchen.tech/2021/03/710a5ed8.html</id>
    <published>2021-03-06T16:06:40.000Z</published>
    <updated>2021-03-06T16:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="github-action-持续集成"><a href="#github-action-持续集成" class="headerlink" title="github action 持续集成"></a>github action 持续集成</h3><p>原先一直觉得 hexo 慢，每次写完文章，clean 一下再 generate 然后 deploy 都要好久于是换了 hugo，但是 hexo 毕竟还是主题多，于是还是回来用这个了。最近发现个解决办法，就是使用持续集成，提交代码之后的事情让别人帮你做，有很多其他的 CI&amp;CD 工具，但这次我是用的是 github 自带的 Github Action。</p><span id="more"></span><h4 id="前提背景"><a href="#前提背景" class="headerlink" title="前提背景"></a>前提背景</h4><p>首先这篇文章的前提是假设你了解 hexo 的工作原理，以及知道如何利用 hexo 去部署自己生成的博客静态文件。这里简单介绍一下，首先 hexo 是一个前端框架，会编译 markdown 文件，生成静态的 html 等静态资源文件。然后在 hexo 博客项目中安装<code>hexo-deployer-git</code>等插件可以把生成在 public 文件夹中的静态资源文件通过 git 协议发送到目标服务器，可以是自己部署的服务器，也可以是第三方提供的托管服务，比如 github、国内的 coding 等。</p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>首先，假设你在 github 上面有两个项目，一个是 username.github.io，一个是 blog 项目。前者是我们的博客站点的静态资源文件，后者是博客项目的源文件，也就是一个 hexo 项目。那么我们只要按照下列步骤操作即可：</p><ol><li>通过使用<code>ssh-keygen -f github-deploy-key</code>来生成一对密钥对</li><li>将密钥中的公钥，也就是<code>github-deploy-key.pub</code>中的内容复制出来，在 username.github.io 项目设置里的 deploy keys 中新建<code>HEXO_DEPLOY_PUB</code>变量，将内容粘贴进去</li><li>在 blog 项目中，在设置中的 Secrets 中新建<code>HEXO_DEPLOY_PRI</code>变量，将前面生成的密钥对中的私钥，也就是<code>github-deploy-key</code>中的内容粘贴进去</li><li>然后在 blog 项目中的 Actions 中申请新建一个脚本，在脚本的编辑框中粘贴下方配置代码</li><li>然后编辑博客源码文件，当推送到 github 的时候，就会执行 action 脚本，将在 github 服务器上生成的静态博客文件，部署到 Github Pages</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">HEXO</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">node-version:</span> [<span class="number">10.</span><span class="string">x</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configuration</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">HEXO_DEPLOY_PRI:</span> <span class="string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name &quot;username&quot;</span></span><br><span class="line"><span class="string">          git config --global user.email &quot;user@example.com&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm i -g hexo-cli</span></span><br><span class="line"><span class="string">          npm i</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">g</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程</a></li><li><a href="https://hdj.me/github-actions-hexo-cicd/">如何正确的使用 GitHub Actions 实现 Hexo 博客的 CICD</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;github-action-持续集成&quot;&gt;&lt;a href=&quot;#github-action-持续集成&quot; class=&quot;headerlink&quot; title=&quot;github action 持续集成&quot;&gt;&lt;/a&gt;github action 持续集成&lt;/h3&gt;&lt;p&gt;原先一直觉得 hexo 慢，每次写完文章，clean 一下再 generate 然后 deploy 都要好久于是换了 hugo，但是 hexo 毕竟还是主题多，于是还是回来用这个了。最近发现个解决办法，就是使用持续集成，提交代码之后的事情让别人帮你做，有很多其他的 CI&amp;amp;CD 工具，但这次我是用的是 github 自带的 Github Action。&lt;/p&gt;</summary>
    
    
    
    <category term="博客" scheme="https://blog.jiangchen.tech/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>聊聊 HashMap</title>
    <link href="https://blog.jiangchen.tech/2020/05/24712328.html"/>
    <id>https://blog.jiangchen.tech/2020/05/24712328.html</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-05-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试的时候，当面试官问你 Java 基础，HashMap 可以说是一个绕不过去的话题，哪怕其他容器（比如 ArrayList，LinkedList）都不问，HashMap 也是不能不问的。不仅仅因为在平时工作中，HashMap 是一个很常用的数据结构，而且由 HashMap 这个数据结构其实能引出很多问题。比如最基本的 get()、put() 方法是吧，get() 就可以聊聊 equals() 方法跟 hashCode() 方法，这算是 Java 基础了吧；稍微升级一下难度，聊聊扩容过程，线程安全问题，进而引申到 ConcurrentHashMap，引申到多线程，引申到 Synchronized 关键字，引申到 JVM 虚拟机是吧，你看这样一联想，整个都串到一起了。</p><span id="more"></span><h1 id="谈谈哈希表的历史"><a href="#谈谈哈希表的历史" class="headerlink" title="谈谈哈希表的历史"></a>谈谈哈希表的历史</h1><p>哈希表在工作中是个很常用的数据结构，因为较好的兼顾了修改跟查找的性能。JDK1.0 中最早实现这个数据结构的类是 HashTable，而且更贴心的是这个类是线程安全的。理论上，只要想使用哈希表这个数据结构的的地方，用 HashTable 就肯定不会有问题。但是凡事都是有代价的，在实现了线程安全的同时，其实是极大地牺牲了性能的。简单翻一下 HashTable 的源码，看 get() 跟 put() 两个方法，可以看到这两个方法都被加了<code>synchronized</code>关键字，这也是 HashTable 线程安全的原因。</p><p>但是你想，直接把整个对象锁住，这是不是小题大做了，尤其是在单线程的场景下，就比如一个业务请求进来，在这个请求的处理过程中新建了一个哈希表，去对哈希表进行一些操作的时候，每次都上锁是不是过分了？其实就他一个线程操作，根本没必要去上锁，全程绿灯直接操作就行了。所以在 JDK1.2，我们有了一个新的类，HashMap。这个类并不是线程安全的，也意味着在单线程情况下，他没有为了保证线程安全而引入的不必要的开销，所以性能很好。于是，那个时候，没有线程安全要求的，直接使用 HashMap 就行了，有线程安全要求，比如某些全局变量什么的多线程访问的情景，那就直接使用 HashTable。</p><p>但其实前面我们也说了 HashTable 实现线程安全的方式十分简单粗暴，直接对整个哈希表加了锁，这就导致在高并发场景下频繁操作哈希表的时候，性能较差。于是在 JDK1.5 里面，并发大师 Doug Lea 为我们带来了 ConcurrentHashMap，通过粒度更细的锁，减少了锁的竞争，从而实现了更好的性能。</p><h1 id="HashMap-底层原理"><a href="#HashMap-底层原理" class="headerlink" title="HashMap 底层原理"></a>HashMap 底层原理</h1><h2 id="HashMap-的变迁"><a href="#HashMap-的变迁" class="headerlink" title="HashMap 的变迁"></a>HashMap 的变迁</h2><p>在不同版本的 JDK 中，HashMap 是在不停优化的。</p><ul><li>比如 JDK1.6 里面 new HashMap 时，开辟了内存空间，如果不使用，则浪费内存；JDK1.7 里面改成了懒加载，new HashMap 并没有开辟内存空间，节约了内存空间</li><li>1.8 优化了 hashCode 算法：高 16 位异或（XOR）低 16 位 主要是增加了扰动，减少了哈希碰撞的几率</li><li>1.8 里面优化了 hash 碰撞较多情况下的性能问题（链表长度限制为 8，过长时会将链表转换为 TreeNode（红黑树））</li></ul><h2 id="类继承关系"><a href="#类继承关系" class="headerlink" title="类继承关系"></a>类继承关系</h2><p>Java 为数据结构中的映射定义了一个接口 java.util.Map，此接口主要有四个常用的实现类，分别是 HashMap、Hashtable、LinkedHashMap 和 TreeMap，类继承关系如下图所示：</p><p><img src="http://img.jiangchen.tech/hashmap-relationship.png" alt="类继承关系"></p><p>下面简单介绍一下各个实现类的特点：</p><ul><li><p>HashMap：它根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p></li><li><p>Hashtable：Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p></li><li><p>LinkedHashMap：LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p></li><li><p>TreeMap：TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p></li></ul><p>对于上述四种 Map 类型的类，要求映射中的 key 是不可变对象。不可变对象是指该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map 对象很可能就定位不到映射的位置了。</p><h2 id="HashMap-的底层数据结构"><a href="#HashMap-的底层数据结构" class="headerlink" title="HashMap 的底层数据结构"></a>HashMap 的底层数据结构</h2><p>其实广义来讲，数据结构只有数组跟链表两种，本质上就是看数据在存储的时候是否连续，其他的各种数据结构，比如栈、队列、跳表、树，都可以用数组或者链表来实现。而 HashMap，算是集中了这两者特点的一种数据结构，在很多地方都会用到。比如 Spring 里面存放各种 bean 用的容器，用的就是 ConcurrentHashMap。</p><p>下面插入一张我画的大致的数据结构图：（下述讨论都基于 JDK1.8）</p><p><img src="http://img.jiangchen.tech/HashMap-data-structure.png" alt="HashMap 数据结构"></p><p>但这张图，其实是有问题的，不知道你发现没，哈哈哈，我后边再讲。如图所示，HashMap 底层的数据结构就是数组 + 链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码摘自 JDK 1.8 中 HashMap 部分源码，table 即为我所说的数组，而 Node 即为链表的一个节点，里面有 hash、key、value 以及下一个节点。</p><p>下面分别介绍一下 Node 中的各个字段：</p><ul><li>hash：存储的键值对中 key 的 hash</li><li>key：存储的键值对中的 key</li><li>value：存储的键值对中的 value</li><li>next：指向下一个 Node</li></ul><h2 id="默认配置常量"><a href="#默认配置常量" class="headerlink" title="默认配置常量"></a>默认配置常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>HashMap 容器初始化的容量为 16，默认负载因子为 0.75，树化阈值为 8，反树化阈值为 6，最小的树化容量为 64。</p><h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>负载因子（LOAD_FACTOR）结合容量（CAPACITY），其实就得到了 HashMap 扩容的一个阈值，大于这个阈值的时候，HashMap 就会进行 resize() 扩容操作。至于负载因子为什么是 0.75，源码里的注释简单提了一嘴，其实就是不说我们也能猜出来。</p><blockquote><p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs.  Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the <strong>HashMap</strong> class, including <strong>get</strong> and <strong>put</strong>).</p></blockquote><p>其实就是权衡了空间占用跟查找效率，负载因子太高固然节省空间，但查找效率也会因此下降，包括 get 跟 set 等操作。</p><p>回到上边那张图，对于初始容量 16，负载因子 0.75 来说，超过 12，也就是图中画的 13 个元素，就会触发扩容，所以我前面说那张图有问题。但当时画的时候随手画的，也懒得改了，就随它去吧。</p><h2 id="Hash-算法"><a href="#Hash-算法" class="headerlink" title="Hash 算法"></a>Hash 算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述算法可知，HashMap 中可以存放 key 为 null 的值，放在首位。而对于哈希值，是将高 16 位与低 16 位进行异或运算，这样做的目的主要是尽量保证 hash 值的均匀，通过这样一个扰动函数，减小了 hash 冲突的概率。</p><p>然后再通过<code>(n - 1) &amp; hash</code>这个 hash 值与数组的长度进行取模运算，决定这个键值对该放入 table 中的哪个 Node 中。</p><h2 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a>扩容过程</h2><p>当容量大于阈值的时候，就会触发 HashMap 的扩容操作。扩容操作其实就是新建一个容量是原先数组两倍的新数组，将原先小数组的元素重新哈希到新的数组上。因为容量是 2 的幂，扩容的时候，元素要么在原位置，要么往后移动原来的容量大小的位置，这时候使用的是下面这个算法：</p><blockquote><p>e.hash &amp; oldCap</p></blockquote><p>如果得到的结果为零，则在原位置；反之，则将其向高位移动 oldCap 大小的位置。</p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>教科书上告诉我们，碰到哈希冲突的时候，一般有两种解决办法：<strong>开放定址法</strong>跟<strong>链表法</strong>。</p><p>HashMap 选择的是链表法来解决哈希冲突的，也十分好理解。简单来说就是当哈希冲突的时候，将哈希冲突的元素挂到一条链表上，至于查找的时候具体是哪个元素，就需要再去链表上比较查出来了。</p><h1 id="HashMap-常用方法"><a href="#HashMap-常用方法" class="headerlink" title="HashMap 常用方法"></a>HashMap 常用方法</h1><h2 id="put-流程"><a href="#put-流程" class="headerlink" title="put 流程"></a>put 流程</h2><ul><li>对 key 的 hashCode() 做 hash 运算，计算 index；</li><li>如果没碰撞直接放到 table 里；</li><li>如果碰撞了，以链表的形式存在 table 后；</li><li>如果碰撞导致链表过长（大于等于 TREEIFY_THRESHOLD)，就把链表转换成红黑树 (JDK1.8 中的改动）；</li><li>如果节点已经存在就替换 old value（保证 key 的唯一性）</li><li>如果 table 满了（超过 load factor*current capacity)，就要 resize。</li></ul><h2 id="get-流程"><a href="#get-流程" class="headerlink" title="get 流程"></a>get 流程</h2><ul><li>对 key 的 hashCode() 做 hash 运算，计算 index;</li><li>如果在 table 里的第一个节点里直接命中，则直接返回；</li><li>如果有冲突，则通过 key.equals(k) 去查找对应的 Node；<ul><li>若为树，则在树中通过 key.equals(k) 查找，$O(\log n)$；</li><li>若为链表，则在链表中通过 key.equals(k) 查找，$O(n)$。</li></ul></li></ul><h2 id="链表跟红黑树互转"><a href="#链表跟红黑树互转" class="headerlink" title="链表跟红黑树互转"></a>链表跟红黑树互转</h2><p>虽然源码中说了，根据泊松分布，哈希冲突的概率很低。但是如果真碰到一些极端情况，比如写死了 HashCode，那么那个 Node 上的元素过多，是会从链表转换成红黑树的。这里其实有一点就是并不是链表长度达到 8 就会转成红黑树。还有另外一个前提条件，就是整个哈希表容量要大于等于树化阈值，默认的树化阈值是 64，因为如果哈希表容量过小就用红黑树，可能会引起频繁扩容跟链表树化之间的冲突，性能并不一定比链表好。所以，在大容量的哈希表中，最极端的情况也就是通过红黑树来查找元素，这种情况下的算法复杂度是$O(\log n)$，明显好于链表的$O(n)$。</p><p>这里其实经常容易被问到的另一个问题就是：为什么用的是红黑树，而不是 AVL 树。</p><p>要回答这个问题就要回到这两种数据结构的特点上面。红黑树的查询性能略微逊色于 AVL 树，因为它比 avl 树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的 avl 树最多多一次比较，但是，红黑树在插入和删除上完爆 avl 树，avl 树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于 avl 树为了维持平衡的开销要小得多。所以，对于 HashMap 这种频繁读写的数据结构，选择红黑树相比 AVL 树是更好的选择。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单总结了 JDK 中哈希表这一数据结构的演变，介绍了 HashMap 的一些底层原理和常用方法，里面掺杂了大量个人主观色彩的见解，如果有错误的地方可以留言一起讨论，希望大家都能够有所收获。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面试的时候，当面试官问你 Java 基础，HashMap 可以说是一个绕不过去的话题，哪怕其他容器（比如 ArrayList，LinkedList）都不问，HashMap 也是不能不问的。不仅仅因为在平时工作中，HashMap 是一个很常用的数据结构，而且由 HashMap 这个数据结构其实能引出很多问题。比如最基本的 get()、put() 方法是吧，get() 就可以聊聊 equals() 方法跟 hashCode() 方法，这算是 Java 基础了吧；稍微升级一下难度，聊聊扩容过程，线程安全问题，进而引申到 ConcurrentHashMap，引申到多线程，引申到 Synchronized 关键字，引申到 JVM 虚拟机是吧，你看这样一联想，整个都串到一起了。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 集合" scheme="https://blog.jiangchen.tech/categories/java-%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL 概览</title>
    <link href="https://blog.jiangchen.tech/2019/10/b0dd67a.html"/>
    <id>https://blog.jiangchen.tech/2019/10/b0dd67a.html</id>
    <published>2019-10-23T00:00:00.000Z</published>
    <updated>2019-10-23T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-总结与分享"><a href="#MySQL-总结与分享" class="headerlink" title="MySQL 总结与分享"></a>MySQL 总结与分享</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="mysql 架构概览"> </p><span id="more"></span><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在 show processlist 命令中看到它。文本中这个图是 show processlist 的结果，其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： <code>Lost connection to MySQL server during query</code>。</p><p>这时候如果你要继续，就需要重连，然后再执行请求了。数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。怎么解决这个问题呢？可以考虑以下两种方案。</p><ul><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ul><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>但是大多数情况下不建议使用查询缓存，为什么呢？因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用 <code>SQL_CACHE</code> 显式指定，像下面这个语句一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><p>需要注意的是，MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>既可以先从表 t1 里面取出 c&#x3D;10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。也可以先从表 t2 里面取出 d&#x3D;20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示 （在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">user</span> <span class="string">&#x27;b&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中。</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MySQL-总结与分享&quot;&gt;&lt;a href=&quot;#MySQL-总结与分享&quot; class=&quot;headerlink&quot; title=&quot;MySQL 总结与分享&quot;&gt;&lt;/a&gt;MySQL 总结与分享&lt;/h1&gt;&lt;h2 id=&quot;基础架构&quot;&gt;&lt;a href=&quot;#基础架构&quot; class=&quot;headerlink&quot; title=&quot;基础架构&quot;&gt;&lt;/a&gt;基础架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png&quot; alt=&quot;mysql 架构概览&quot;&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.jiangchen.tech/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>前端入门文档索引</title>
    <link href="https://blog.jiangchen.tech/2019/07/b310d7ef.html"/>
    <id>https://blog.jiangchen.tech/2019/07/b310d7ef.html</id>
    <published>2019-07-12T00:00:00.000Z</published>
    <updated>2019-07-12T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>前端开发的基础知识可以在 <strong>MDN Web Docs</strong> 获得，主要是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript</a>。</p><span id="more"></span><h1 id="语言相关"><a href="#语言相关" class="headerlink" title="语言相关"></a>语言相关</h1><p>JavaScript 语言本身在不断演进，一个比较重要的版本更新是 EcmaScript 2015 （即 ES6），具体可参阅以下文档：</p><ul><li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门</a></li><li><a href="https://github.com/DrkSephy/es6-cheatsheet">es6-cheatsheet</a></li></ul><p>JavaScript 本身没有类型检查，因此微软推出了它的严格超集 TypeScript，提供静态类型检查，具体可参阅以下文档：</p><ul><li><a href="http://www.typescriptlang.org/docs/handbook/basic-types.html">官方手册</a></li><li><a href="https://www.tslang.cn/docs/handbook/basic-types.html">官方手册中文版</a></li><li><a href="https://basarat.gitbooks.io/typescript">TypeScript Deep Dive</a></li></ul><h1 id="React-相关"><a href="#React-相关" class="headerlink" title="React 相关"></a>React 相关</h1><p>React 是 Facebook 推出的前端 UI 开发框架，具体可参考以下资料：</p><ul><li><a href="https://reactjs.org/docs/getting-started.html">官方文档</a></li><li><a href="https://zh-hans.reactjs.org/docs/getting-started.html">官方文档中文版</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/03/react.html">React 入门实例教程</a></li></ul><p>在前端路由方面，有比较多的 React 库可供选择，比较流行的是 React Router，可参考：</p><ul><li><a href="https://reacttraining.com/react-router/web/guides/quick-start">React Router 官方文档</a></li><li><a href="https://segmentfault.com/a/1190000010174260">React Router 4 简易入门</a></li></ul><h1 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h1><p>当 app 状态共享及变化很复杂的时候需要使用全局状态管理的库，比较流行的是 Redux：</p><ul><li><a href="https://redux.js.org/introduction/getting-started">Redux 官方文档</a></li><li><a href="http://cn.redux.js.org/index.html">Redux 中文文档</a></li></ul><p>Redux 可用于不同的前端框架，在 React 项目里使用需要用到相关的绑定库：</p><ul><li><a href="https://react-redux.js.org/introduction/quick-start">react-redux 官方文档</a></li><li><a href="https://www.redux.org.cn/docs/react-redux">react-redux 官方文档中文版</a></li></ul><p>Redux 本身不处理异步操作及副作用，需要集成其他库，主要有以下几个：</p><ul><li><a href="https://github.com/reduxjs/redux-thunk">redux-thunk</a></li><li><a href="https://github.com/redux-saga/redux-saga">redux-saga</a></li><li><a href="https://github.com/redux-observable/redux-observable">redux-observable</a></li></ul><h1 id="综合相关"><a href="#综合相关" class="headerlink" title="综合相关"></a>综合相关</h1><p><a href="https://github.com/Microsoft/TypeScript-React-Starter#typescript-react-starter">TypeScript + React + Redux 项目脚手架</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;前端开发的基础知识可以在 &lt;strong&gt;MDN Web Docs&lt;/strong&gt; 获得，主要是 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTML&quot;&gt;HTML&lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS&quot;&gt;CSS&lt;/a&gt;，&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript&quot;&gt;JavaScript&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://blog.jiangchen.tech/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 IO 的一些理解</title>
    <link href="https://blog.jiangchen.tech/2019/04/701d90cf.html"/>
    <id>https://blog.jiangchen.tech/2019/04/701d90cf.html</id>
    <published>2019-04-05T00:00:00.000Z</published>
    <updated>2019-04-05T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见的-IO-模型"><a href="#常见的-IO-模型" class="headerlink" title="常见的 IO 模型"></a>常见的 IO 模型</h2><p>常见的 IO 模型有以下五种：</p><ul><li>阻塞式 IO 模型</li><li>非阻塞 IO 模型</li><li>IO 复用模型</li><li>信号驱动 IO 模型</li><li>异步 IO 模型<span id="more"></span><img src="https://img.jiangchen.tech/20210505011909.png" alt="五种 IO 模型"></li></ul><h2 id="阻塞-IO-模型"><a href="#阻塞-IO-模型" class="headerlink" title="阻塞 IO 模型"></a>阻塞 IO 模型</h2><p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。</p><p>当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。</p><p>典型的阻塞 IO 模型的例子为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = socket.read();</span><br></pre></td></tr></table></figure><p>如果数据没有就绪，就会一直阻塞在 read 方法。</p><h2 id="非阻塞-IO-模型"><a href="#非阻塞-IO-模型" class="headerlink" title="非阻塞 IO 模型"></a>非阻塞 IO 模型</h2><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//典型的非阻塞 IO 模型一般如下：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123;</span><br><span class="line">        处理数据</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p><h2 id="多路复用-IO-模型"><a href="#多路复用-IO-模型" class="headerlink" title="多路复用 IO 模型"></a>多路复用 IO 模型</h2><p>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。</p><p>在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。</p><p>在 Java NIO 中，是通过 selector.select() 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p><p>也许有朋友会说，我可以采用 多线程 + 阻塞 IO 达到类似的效果，但是由于在多线程 + 阻塞 IO 中，每个 socket 对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p><p>而多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。</p><p>另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p><p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p><h2 id="信号驱动-IO-模型"><a href="#信号驱动-IO-模型" class="headerlink" title="信号驱动 IO 模型"></a>信号驱动 IO 模型</h2><p>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p><h2 id="异步-IO-模型"><a href="#异步-IO-模型" class="headerlink" title="异步 IO 模型"></a>异步 IO 模型</h2><p>异步 IO 模型是比较理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</p><p>也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 iO 函数进行实际的读写操作。</p><p>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。</p><p>前面四种 IO 模型实际上都属于同步 IO，只有最后一种是真正的异步 IO，因为无论是多路复用 IO 还是信号驱动模型，IO 操作的第 2 个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;常见的-IO-模型&quot;&gt;&lt;a href=&quot;#常见的-IO-模型&quot; class=&quot;headerlink&quot; title=&quot;常见的 IO 模型&quot;&gt;&lt;/a&gt;常见的 IO 模型&lt;/h2&gt;&lt;p&gt;常见的 IO 模型有以下五种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式 IO 模型&lt;/li&gt;
&lt;li&gt;非阻塞 IO 模型&lt;/li&gt;
&lt;li&gt;IO 复用模型&lt;/li&gt;
&lt;li&gt;信号驱动 IO 模型&lt;/li&gt;
&lt;li&gt;异步 IO 模型</summary>
    
    
    
    <category term="计算机基础" scheme="https://blog.jiangchen.tech/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美（五）</title>
    <link href="https://blog.jiangchen.tech/2019/04/54971246.html"/>
    <id>https://blog.jiangchen.tech/2019/04/54971246.html</id>
    <published>2019-04-01T00:00:00.000Z</published>
    <updated>2019-04-01T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序（sort）-下"><a href="#排序（sort）-下" class="headerlink" title="排序（sort）- 下"></a>排序（sort）- 下</h1><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="归并排序算法原理"><a href="#归并排序算法原理" class="headerlink" title="归并排序算法原理"></a>归并排序算法原理</h3><p>先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">递推公式：merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line">终止条件：p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure><h3 id="归并排序代码实现"><a href="#归并排序代码实现" class="headerlink" title="归并排序代码实现"></a>归并排序代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归并排序算法，a 是数组，n 表示数组大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        mergeSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSortInternally</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取 p 到 r 之间的中间位置 q, 防止（p+r）的和超过 int 类型最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> p + (r - p) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 分治递归</span></span><br><span class="line">        mergeSortInternally(a, p, q);</span><br><span class="line">        mergeSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span></span><br><span class="line">        merge(a, p, q, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> q + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 初始化变量 i, j, k</span></span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r - p + <span class="number">1</span>]; <span class="comment">// 申请一个大小跟 a[p...r] 一样的临时数组</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">                tmp[k++] = a[i++]; <span class="comment">// i++等于 i:=i+1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k++] = a[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> q;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">            start = j;</span><br><span class="line">            end = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将剩余的数据拷贝到临时数组 tmp</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            tmp[k++] = a[start++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 tmp 中的数组拷贝回 a[p...r]</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r - p; ++i) &#123;</span><br><span class="line">            a[p + i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序性能分析"><a href="#归并排序性能分析" class="headerlink" title="归并排序性能分析"></a>归并排序性能分析</h3><h4 id="归并排序算法稳定性："><a href="#归并排序算法稳定性：" class="headerlink" title="归并排序算法稳定性："></a>归并排序算法稳定性：</h4><p>归并排序稳不稳定关键要看 merge() 函数，也就是两个子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们就可以像伪代码中那样，先把 A[p…q] 中的元素放入 tmp 数组，这样 就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一种稳定排序算法。</p><h4 id="归并排序时间复杂度："><a href="#归并排序时间复杂度：" class="headerlink" title="归并排序时间复杂度："></a>归并排序时间复杂度：</h4><p>分析归并排序的时间复杂度就是分析递归代码的时间复杂度，如何分析递归代码的时间复杂度？</p><p>递归的适用场景是一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果。若定义求解问题 a 的时间是 T(a)，则求解问题 b、c 的时间分别是 T(b) 和 T(c)，那就可以得到这样的递推公式：T(a) &#x3D; T(b) + T(c) + K，其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。这里有一个重要的结论：不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。套用这个公式，那么归并排序的时间复杂度就可以表示为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1，其中 n 就是 merge() 函数合并两个子数组的的时间复杂度 O(n)。</span><br><span class="line">T(n) = 2*T(n/2) + n</span><br><span class="line">     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n</span><br><span class="line">     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n</span><br><span class="line">     = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     = 2^k * T(n/2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure><p>当 T($n&#x2F;2^k$)&#x3D;T(1) 时，也就是 $n&#x2F;2^k&#x3D;1$，我们得到$k&#x3D;\log_2 n$。将 k 带入上面的公式就得到$T(n)&#x3D;Cn+n\log_2 n$。如用大 O 表示法，T(n) 就等于 O($n\log n$)。所以，归并排序的是复杂度时间复杂度就是 O($n\log n$)。</p><h4 id="归并排序空间复杂度："><a href="#归并排序空间复杂度：" class="headerlink" title="归并排序空间复杂度："></a>归并排序空间复杂度：</h4><p>归并排序算法不是原地排序算法，空间复杂度是 O(n)</p><p>为什么？因为归并排序的合并函数，在合并两个数组为一个有序数组时，需要借助额外的存储空间。为什么空间复杂度是 O(n) 而不是 O($n\log n$) 呢？如果我们按照分析递归的时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 O($n\log n$)，但这种分析思路是有问题的！因为，在实际上，递归代码的空间复杂度并不是像时间复杂度那样累加，而是这样的过程，即在每次合并过程中都需要申请额外的内存空间，但是合并完成后，临时开辟的内存空间就被释放掉了，在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时空间再大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><h3 id="快速排序算法原理"><a href="#快速排序算法原理" class="headerlink" title="快速排序算法原理"></a>快速排序算法原理</h3><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。然后遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 povit 放到中间。经过这一步之后，数组 p 到 r 之间的数据就分成了 3 部分，前面 p 到 q-1 之间都是小于 povit 的，中间是 povit，后面的 q+1 到 r 之间是大于 povit 的。根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">递推公式：quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</span><br><span class="line">终止条件：p &gt;= r</span><br></pre></td></tr></table></figure><h3 id="快速排序代码实现"><a href="#快速排序代码实现" class="headerlink" title="快速排序代码实现"></a>快速排序代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序，a 是数组，n 表示数组的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        quickSortInternally(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序递归函数，p,r 为下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSortInternally</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> partition(a, p, r); <span class="comment">// 获取分区点</span></span><br><span class="line">        quickSortInternally(a, p, q - <span class="number">1</span>);</span><br><span class="line">        quickSortInternally(a, q + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[r];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> p; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[i];</span><br><span class="line">                    a[i++] = a[j];</span><br><span class="line">                    a[j] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[r];</span><br><span class="line">        a[r] = tmp;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序性能分析"><a href="#快速排序性能分析" class="headerlink" title="快速排序性能分析"></a>快速排序性能分析</h3><h4 id="快速排序算法稳定性："><a href="#快速排序算法稳定性：" class="headerlink" title="快速排序算法稳定性："></a>快速排序算法稳定性：</h4><p>因为分区过程中涉及交换操作，如果数组中有两个 8，其中一个是 pivot，经过分区处理后，后面的 8 就有可能放到了另一个 8 的前面，先后顺序就颠倒了，所以快速排序是不稳定的排序算法。比如数组 [1,2,3,9,8,11,8]，取后面的 8 作为 pivot，那么分区后就会将后面的 8 与 9 进行交换。</p><h4 id="快速排序时间复杂度：最好、最坏、平均情况"><a href="#快速排序时间复杂度：最好、最坏、平均情况" class="headerlink" title="快速排序时间复杂度：最好、最坏、平均情况"></a>快速排序时间复杂度：最好、最坏、平均情况</h4><p>快排也是用递归实现的，所以时间复杂度也可以用递推公式表示。</p><p>如果每次分区操作都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并的相同。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = 2*T(n/2) + n； n&gt;1</span><br></pre></td></tr></table></figure><p>所以，快排的时间复杂度也是 O($n\log n$)。</p><p>如果数组中的元素原来已经有序了，比如 1，3，5，6，8，若每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的，需要进行大约 n 次的分区，才能完成整个快排过程，而每次分区我们平均要扫描大约 n&#x2F;2 个元素，这种情况下，快排的时间复杂度就是 O($n^2$)。</p><p>前面两种情况，一个是分区及其均衡，一个是分区极不均衡，它们分别对应了快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均时间复杂度是多少呢？T(n) 大部分情况下是 O($n\log n$)，只有在极端情况下才是退化到 O($n^2$)，而且我们也有很多方法将这个概率降低。</p><h4 id="快速排序空间复杂度："><a href="#快速排序空间复杂度：" class="headerlink" title="快速排序空间复杂度："></a>快速排序空间复杂度：</h4><p>快排是一种原地排序算法，空间复杂度是 O(1)</p><h2 id="归并排序与快速排序的区别"><a href="#归并排序与快速排序的区别" class="headerlink" title="归并排序与快速排序的区别"></a>归并排序与快速排序的区别</h2><p>归并和快排用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？</p><ol><li>归并排序，是先递归调用，再进行合并，合并的时候进行数据的交换。所以它是自下而上的排序方式。何为自下而上？就是先解决子问题，再解决父问题。</li><li>快速排序，是先分区，在递归调用，分区的时候进行数据的交换。所以它是自上而下的排序方式。何为自上而下？就是先解决父问题，再解决子问题。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;排序（sort）-下&quot;&gt;&lt;a href=&quot;#排序（sort）-下&quot; class=&quot;headerlink&quot; title=&quot;排序（sort）- 下&quot;&gt;&lt;/a&gt;排序（sort）- 下&lt;/h1&gt;&lt;h2 id=&quot;归并排序（Merge-Sort）&quot;&gt;&lt;a href=&quot;#归并排序（Merge-Sort）&quot; class=&quot;headerlink&quot; title=&quot;归并排序（Merge Sort）&quot;&gt;&lt;/a&gt;归并排序（Merge Sort）&lt;/h2&gt;&lt;h3 id=&quot;归并排序算法原理&quot;&gt;&lt;a href=&quot;#归并排序算法原理&quot; class=&quot;headerlink&quot; title=&quot;归并排序算法原理&quot;&gt;&lt;/a&gt;归并排序算法原理&lt;/h3&gt;&lt;p&gt;先把数组从中间分成前后两部分，然后对前后两部分分别进行排序，再将排序好的两部分合并到一起，这样整个数组就有序了。这就是归并排序的核心思想。如何用递归实现归并排序呢？写递归代码的技巧就是分写得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。递推公式怎么写？如下&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.jiangchen.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美（四）</title>
    <link href="https://blog.jiangchen.tech/2019/02/3b09d701.html"/>
    <id>https://blog.jiangchen.tech/2019/02/3b09d701.html</id>
    <published>2019-02-20T00:00:00.000Z</published>
    <updated>2019-02-20T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序（sort）-上"><a href="#排序（sort）-上" class="headerlink" title="排序（sort）- 上"></a>排序（sort）- 上</h1><h2 id="几种经典排序算法及其时间复杂度级别"><a href="#几种经典排序算法及其时间复杂度级别" class="headerlink" title="几种经典排序算法及其时间复杂度级别"></a>几种经典排序算法及其时间复杂度级别</h2><ul><li>冒泡、插入、选择：O($n^2$) 基于比较</li><li>快排、归并：O($n\log n$) 基于比较</li><li>计数、基数、桶：O(n) 不基于比较</li></ul><span id="more"></span><h2 id="如何分析一个排序算法"><a href="#如何分析一个排序算法" class="headerlink" title="如何分析一个排序算法"></a>如何分析一个排序算法</h2><h3 id="学习排序算法的思路"><a href="#学习排序算法的思路" class="headerlink" title="学习排序算法的思路"></a>学习排序算法的思路</h3><p>明确原理、掌握实现以及分析性能。</p><h3 id="分析排序算法性能"><a href="#分析排序算法性能" class="headerlink" title="分析排序算法性能"></a>分析排序算法性能</h3><p>从执行效率、内存消耗以及稳定性 3 个方面分析排序算法的性能。</p><h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><p>从以下 3 个方面来衡量：</p><ol><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数、低阶：排序的数据量比较小时考虑</li><li>比较次数和交换（或移动）次数</li></ol><h3 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h3><p>通过空间复杂度来衡量。</p><p>针对排序算法的空间复杂度，引入原地排序的概念，原地排序算法就是指空间复杂度为 O(1) 的排序算法。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果待排序的序列中存在值等的元素，经过排序之后，相等元素之间原有的先后顺序不变，就说明这个排序算法时稳定的。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="冒泡排序算法原理"><a href="#冒泡排序算法原理" class="headerlink" title="冒泡排序算法原理"></a>冒泡排序算法原理</h3><ol><li>冒泡排序只会操作相邻的两个数据。</li><li>对相邻两个数据进行比较，看是否满足大小关系要求，若不满足让它俩互换。</li><li>一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</li><li>优化：若某次冒泡不存在数据交换，则说明已经达到完全有序，所以终止冒泡。</li></ol><h3 id="冒泡排序代码实现"><a href="#冒泡排序代码实现" class="headerlink" title="冒泡排序代码实现"></a>冒泡排序代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 冒泡排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n 数组长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[j];</span><br><span class="line">                a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">                a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;  <span class="comment">// 表示有数据交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序性能分析"><a href="#冒泡排序性能分析" class="headerlink" title="冒泡排序性能分析"></a>冒泡排序性能分析</h3><h4 id="冒泡排序的执行效率"><a href="#冒泡排序的执行效率" class="headerlink" title="冒泡排序的执行效率"></a>冒泡排序的执行效率</h4><p>最小时间复杂度：数据完全有序时，只需进行一次冒泡操作即可，时间复杂度是 O(n)。<br>最大时间复杂度：数据倒序排序时，需要 n 次冒泡操作，时间复杂度是 O($n^2$)。<br>平均时间复杂度：通过有序度和逆序度来分析。</p><p>什么是有序度？</p><p>有序度是数组中具有有序关系的元素对的个数，比如<code>[2,4,3,1,5,6]</code>这组数据的有序度就是 11，分别是<code>[2,4][2,3][2,5][2,6][4,5][4,6][3,5][3,6][1,5][1,6][5,6]</code>。同理，对于一个倒序数组，比如<code>[6,5,4,3,2,1]</code>，有序度是 0；对于一个完全有序的数组，比如<code>[1,2,3,4,5,6]</code>，有序度为$n*(n-1)&#x2F;2$，也就是 15，完全有序的情况称为满有序度。</p><p>什么是逆序度？</p><p>逆序度的定义正好和有序度相反。核心公式：逆序度&#x3D;满有序度-有序度。</p><p>排序过程，就是有序度增加，逆序度减少的过程，最后达到满有序度，就说明排序完成了。</p><p>冒泡排序包含两个操作原子，即比较和交换，每交换一次，有序度加 1。不管算法如何改进，交换的次数总是确定的，即逆序度。<br>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏的情况初始有序度为 0，所以要进行 n*(n-1)&#x2F;2 交换。最好情况下，初始状态有序度是$n*(n-1)&#x2F;2$，就不需要进行交互。我们可以取个中间值$n*(n-1)&#x2F;4$，来表示初始有序度既不是很高也不是很低的平均情况。<br>换句话说，平均情况下，需要 $n*(n-1)&#x2F;4$ 次交换操作，比较操作可定比交换操作多，而复杂度的上限是 O($n^2$)，所以平均情况时间复杂度就是 O($n^2$)。</p><h4 id="冒泡排序的空间复杂度"><a href="#冒泡排序的空间复杂度" class="headerlink" title="冒泡排序的空间复杂度"></a>冒泡排序的空间复杂度</h4><p>每次交换仅需 1 个临时变量，故空间复杂度为 O(1)，是原地排序算法。</p><h4 id="冒泡排序的算法稳定性"><a href="#冒泡排序的算法稳定性" class="headerlink" title="冒泡排序的算法稳定性"></a>冒泡排序的算法稳定性</h4><p>如果两个值相等，就不会交换位置，故是稳定排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序算法原理"><a href="#插入排序算法原理" class="headerlink" title="插入排序算法原理"></a>插入排序算法原理</h3><p>首先，我们将数组中的数据分为 2 个区间，即已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想就是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间中的元素一直有序。重复这个过程，直到未排序中元素为空，算法结束。</p><h3 id="插入排序代码实现"><a href="#插入排序代码实现" class="headerlink" title="插入排序代码实现"></a>插入排序代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 插入排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n 数组长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序性能分析"><a href="#插入排序性能分析" class="headerlink" title="插入排序性能分析"></a>插入排序性能分析</h3><h4 id="插入排序的时间复杂度"><a href="#插入排序的时间复杂度" class="headerlink" title="插入排序的时间复杂度"></a>插入排序的时间复杂度</h4><p>如果要排序的数组已经是有序的，我们并不需要搬移任何数据。只需要遍历一遍数组即可，所以最好时间复杂度是 O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，因此最坏时间复杂度是 O($n^2$)。而在一个数组中插入一个元素的平均时间复杂都是 O(n)，插入排序需要 n 次插入，所以平均时间复杂度是 O($n^2$)。</p><h4 id="插入排序的空间复杂度"><a href="#插入排序的空间复杂度" class="headerlink" title="插入排序的空间复杂度"></a>插入排序的空间复杂度</h4><p>从上面的代码可以看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是原地排序算法。</p><h4 id="插入排序的算法稳定性"><a href="#插入排序的算法稳定性" class="headerlink" title="插入排序的算法稳定性"></a>插入排序的算法稳定性</h4><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现的元素的后面，这样就保持原有的顺序不变，所以是稳定的。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="选择排序算法原理"><a href="#选择排序算法原理" class="headerlink" title="选择排序算法原理"></a>选择排序算法原理</h3><p>选择排序算法也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，并将其放置到已排序区间的末尾。</p><h3 id="选择排序代码实现"><a href="#选择排序代码实现" class="headerlink" title="选择排序代码实现"></a>选择排序代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 选择排序</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n 数组长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min]) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">            a[i] = a[min];</span><br><span class="line">            a[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序性能分析"><a href="#选择排序性能分析" class="headerlink" title="选择排序性能分析"></a>选择排序性能分析</h3><h4 id="选择排序的时间复杂度"><a href="#选择排序的时间复杂度" class="headerlink" title="选择排序的时间复杂度"></a>选择排序的时间复杂度</h4><p>选择排序的最好、最坏、平均情况时间复杂度都是 O($n^2$)。为什么？因为无论是否有序，每个循环都会完整执行，没得商量。</p><h4 id="选择排序的空间复杂度"><a href="#选择排序的空间复杂度" class="headerlink" title="选择排序的空间复杂度"></a>选择排序的空间复杂度</h4><p>选择排序算法空间复杂度是 O(1)，是一种原地排序算法。</p><h4 id="选择排序的算法稳定性"><a href="#选择排序的算法稳定性" class="headerlink" title="选择排序的算法稳定性"></a>选择排序的算法稳定性</h4><p>选择排序算法不是一种稳定排序算法，比如<code>[5,8,5,2,9]</code>这个数组，使用选择排序算法第一次找到的最小元素就是 2，与第一个位置的元素 5 交换位置，那第一个 5 和中间的 5 的顺序就变量，所以就不稳定了。正因如此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><h3 id="1-冒泡排序和插入排序的时间复杂度都是-O-n-2-，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？"><a href="#1-冒泡排序和插入排序的时间复杂度都是-O-n-2-，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？" class="headerlink" title="1. 冒泡排序和插入排序的时间复杂度都是 O($n^2$)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？"></a>1. 冒泡排序和插入排序的时间复杂度都是 O($n^2$)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</h3><p>冒泡排序移动数据有 3 条赋值语句，而选择排序的交换位置的只有 1 条赋值语句，因此在有序度相同的情况下，冒泡排序时间复杂度是选择排序的 3 倍，所以，选择排序性能更好。</p><h3 id="2-如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？"><a href="#2-如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？" class="headerlink" title="2. 如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？"></a>2. 如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？</h3><p>一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。</p><h3 id="三种排序算法比较"><a href="#三种排序算法比较" class="headerlink" title="三种排序算法比较"></a>三种排序算法比较</h3><p><img src="https://img.jiangchen.tech/20210505012405.png" alt="三种排序算法比较"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;排序（sort）-上&quot;&gt;&lt;a href=&quot;#排序（sort）-上&quot; class=&quot;headerlink&quot; title=&quot;排序（sort）- 上&quot;&gt;&lt;/a&gt;排序（sort）- 上&lt;/h1&gt;&lt;h2 id=&quot;几种经典排序算法及其时间复杂度级别&quot;&gt;&lt;a href=&quot;#几种经典排序算法及其时间复杂度级别&quot; class=&quot;headerlink&quot; title=&quot;几种经典排序算法及其时间复杂度级别&quot;&gt;&lt;/a&gt;几种经典排序算法及其时间复杂度级别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;冒泡、插入、选择：O($n^2$) 基于比较&lt;/li&gt;
&lt;li&gt;快排、归并：O($n\log n$) 基于比较&lt;/li&gt;
&lt;li&gt;计数、基数、桶：O(n) 不基于比较&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.jiangchen.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美（三）</title>
    <link href="https://blog.jiangchen.tech/2019/02/8c24ce64.html"/>
    <id>https://blog.jiangchen.tech/2019/02/8c24ce64.html</id>
    <published>2019-02-19T00:00:00.000Z</published>
    <updated>2019-02-19T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归（recursion）"><a href="#递归（recursion）" class="headerlink" title="递归（recursion）"></a>递归（recursion）</h1><h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><p>究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。</p><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><span id="more"></span><h2 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h2><p>写递归代码最关键的是写出递推公式，找到终止条件。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><blockquote><p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p></blockquote><p>我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：</p><pre><code>f(n) = f(n-1)+f(n-2)</code></pre><p>有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)&#x3D;1。这个递归终止条件足够吗？我们可以用 n&#x3D;2，n&#x3D;3 这样比较小的数试验一下。</p><p>n&#x3D;2 时，f(2)&#x3D;f(1)+f(0)。如果递归终止条件只有一个 f(1)&#x3D;1，那 f(2) 就无法求解了。所以除了 f(1)&#x3D;1 这一个递归终止条件外，还要有 f(0)&#x3D;1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把 f(2)&#x3D;2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p><p>所以，递归终止条件就是 f(1)&#x3D;1，f(2)&#x3D;2。这个时候，你可以再拿 n&#x3D;3，n&#x3D;4 来验证一下，这个终止条件是否足够并且正确。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;递归（recursion）&quot;&gt;&lt;a href=&quot;#递归（recursion）&quot; class=&quot;headerlink&quot; title=&quot;递归（recursion）&quot;&gt;&lt;/a&gt;递归（recursion）&lt;/h1&gt;&lt;h2 id=&quot;递归需要满足的三个条件&quot;&gt;&lt;a href=&quot;#递归需要满足的三个条件&quot; class=&quot;headerlink&quot; title=&quot;递归需要满足的三个条件&quot;&gt;&lt;/a&gt;递归需要满足的三个条件&lt;/h2&gt;&lt;p&gt;究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个问题的解可以分解为几个子问题的解&lt;/li&gt;
&lt;li&gt;这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样&lt;/li&gt;
&lt;li&gt;存在递归终止条件&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.jiangchen.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美（二）</title>
    <link href="https://blog.jiangchen.tech/2019/02/c13a6d36.html"/>
    <id>https://blog.jiangchen.tech/2019/02/c13a6d36.html</id>
    <published>2019-02-18T00:00:00.000Z</published>
    <updated>2019-02-18T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h1><h2 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h2><p>从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。</p><p>我第一次接触这种数据结构的时候，就对它存在的意义产生了很大的疑惑。因为我觉得，相比数组和链表，栈带给我的只有限制，并没有任何优势。那我直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？</p><span id="more"></span><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</p><h2 id="实现一个栈"><a href="#实现一个栈" class="headerlink" title="实现一个栈"></a>实现一个栈</h2><p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;           <span class="comment">// 栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为 n 的数组空间</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回 false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将 item 放到下标为 count 的位置，并且 count 加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈的时间复杂度、空间复杂度都是 O(1)。</p><p>要实现一个支持动态扩容的栈，可以类似实现动态扩容的数组。</p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul><li>函数调用栈</li><li>表达式求值（后缀表达式）</li><li>括号匹配</li></ul><h1 id="队列（queue）"><a href="#队列（queue）" class="headerlink" title="队列（queue）"></a>队列（queue）</h1><h2 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h2><p>队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。</p><p>我们知道，栈只支持两个基本操作：入栈 push() 和出栈 pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。</p><p>所以，队列跟栈一样，也是一种操作受限的线性表数据结构。</p><p>用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><h2 id="实现一个队列"><a href="#实现一个队列" class="headerlink" title="实现一个队列"></a>实现一个队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    items = <span class="keyword">new</span> <span class="title class_">String</span>[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 tail == n 表示队列已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，确定好队空和队满的判定条件。</p><p>关于避免队头与队尾相遇这个问题，有两种处理办法：</p><ol><li>多占用一个空间储存标记变量</li><li>队列中少存一个，使得队头与队尾不会相遇</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;栈（stack）&quot;&gt;&lt;a href=&quot;#栈（stack）&quot; class=&quot;headerlink&quot; title=&quot;栈（stack）&quot;&gt;&lt;/a&gt;栈（stack）&lt;/h1&gt;&lt;h2 id=&quot;如何理解“栈”？&quot;&gt;&lt;a href=&quot;#如何理解“栈”？&quot; class=&quot;headerlink&quot; title=&quot;如何理解“栈”？&quot;&gt;&lt;/a&gt;如何理解“栈”？&lt;/h2&gt;&lt;p&gt;从栈的操作特性上来看，栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。&lt;/p&gt;
&lt;p&gt;我第一次接触这种数据结构的时候，就对它存在的意义产生了很大的疑惑。因为我觉得，相比数组和链表，栈带给我的只有限制，并没有任何优势。那我直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.jiangchen.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法之美（一）</title>
    <link href="https://blog.jiangchen.tech/2019/02/f12c81ee.html"/>
    <id>https://blog.jiangchen.tech/2019/02/f12c81ee.html</id>
    <published>2019-02-17T00:00:00.000Z</published>
    <updated>2019-02-17T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近人有些低潮，干什么都不得劲。工作也逐渐进入安逸区，没什么有挑战性的工作，都是对之前的重复。想着把计算机基础都好好补一下，系统性的梳理一下，中国大学慕课网上面的国家精品课程看一看，极客时间上面的一些课程也好好学习一下。</p><p>以下的一些总结可能过于简陋，更多的是总纲性质的总结，更多的细枝末节，不懂为什么的，自己去找那些基础来看。简而言之，就是下面的总结很多只说了是什么，没有说为什么。</p><span id="more"></span><h1 id="数据结构与算法总览"><a href="#数据结构与算法总览" class="headerlink" title="数据结构与算法总览"></a>数据结构与算法总览</h1><p><img src="https://img.jiangchen.tech/20210505012538.png" alt="数据结构与算法总览"></p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h3 id="10-个数据结构："><a href="#10-个数据结构：" class="headerlink" title="10 个数据结构："></a>10 个数据结构：</h3><ul><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>散列表</li><li>二叉树</li><li>堆</li><li>跳表</li><li>图</li><li>Trie 树</li></ul><h3 id="10-个算法"><a href="#10-个算法" class="headerlink" title="10 个算法"></a>10 个算法</h3><ul><li>递归</li><li>排序</li><li>二分查找</li><li>搜索</li><li>哈希算法</li><li>贪心算法</li><li>分治算法</li><li>回溯算法</li><li>动态规划</li><li>字符串匹配算法</li></ul><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><img src="https://img.jiangchen.tech/20210505012615.png" alt="算法复杂度量级"></p><p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，<code>多项式量级</code>和<code>非多项式量级</code>。其中，非多项式量级只有两个：O($n^2$) 和 O($n!$)</p><p>复杂度包括<code>时间复杂度</code>和<code>空间复杂度</code>。</p><p>虽然复杂度看似很多，但实际上常用的就下面三种：</p><p><img src="https://img.jiangchen.tech/20210505012642.png" alt="常用的复杂度分析"></p><p>关于复杂度本身，还可以分为：</p><ul><li>最好情况时间复杂度（best case time complexity）：在最理想的情况下，执行这段代码的时间复杂度</li><li>最坏情况时间复杂度（worst case time complexity）：在最糟糕的情况下，执行这段代码的时间复杂度</li><li>平均情况时间复杂度（average case time complexity）：又可以叫做<code>加权平均时间复杂度</code>或者<code>期望时间复杂度</code></li><li>均摊时间复杂度（amortized time complexity）：均摊时间复杂度就是一种特殊的平均时间复杂度（比如对数组进行扩容操作的复杂度）</li></ul><h1 id="学习算法推荐书单"><a href="#学习算法推荐书单" class="headerlink" title="学习算法推荐书单"></a>学习算法推荐书单</h1><p><img src="https://img.jiangchen.tech/20210505012704.png" alt="推荐书单"></p><p>其实除了上述的书单，对于 Java 工程师，我尤其要推荐一本《算法》第四版。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表数据结构"><a href="#线性表数据结构" class="headerlink" title="线性表数据结构"></a>线性表数据结构</h2><p><img src="https://img.jiangchen.tech/20210505012724.png" alt="线性表数据结构"></p><h2 id="非线性表数据结构"><a href="#非线性表数据结构" class="headerlink" title="非线性表数据结构"></a>非线性表数据结构</h2><p><img src="https://img.jiangchen.tech/20210505012744.png" alt="非线性表数据结构"></p><h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><p>关于数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。</p><p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O($\log n$)。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。</p><p>数组由于自身特点，插入、删除等操作比较低效，对于他们的改进可以如下：</p><p>关于插入操作：如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p><p>关于删除操作：我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><h2 id="思考：容器能否完全替代数组？"><a href="#思考：容器能否完全替代数组？" class="headerlink" title="思考：容器能否完全替代数组？"></a>思考：容器能否完全替代数组？</h2><ol><li><p>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 以及动态扩容则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</p></li><li><p>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</p></li><li><p>当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：<code>ArrayList&lt;ArrayList&gt; array</code>。</p></li></ol><h1 id="链表（Linked-list）"><a href="#链表（Linked-list）" class="headerlink" title="链表（Linked list）"></a>链表（Linked list）</h1><h2 id="数组与链表内存分布区别"><a href="#数组与链表内存分布区别" class="headerlink" title="数组与链表内存分布区别"></a>数组与链表内存分布区别</h2><p><img src="https://img.jiangchen.tech/20210505012801.png" alt="数组与链表内存分布区别"></p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="https://img.jiangchen.tech/20210505012817.png" alt="单链表"></p><p>在链表里面，有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><h2 id="循环链表和双向链表"><a href="#循环链表和双向链表" class="headerlink" title="循环链表和双向链表"></a>循环链表和双向链表</h2><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="https://img.jiangchen.tech/20210505012835.png" alt="循环链表"></p><p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<code>约瑟夫问题</code>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><blockquote><p>约瑟夫问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。</p><p>人们站在一个等待被处决的圈子里。 计数从圆圈中的指定点开始，并沿指定方向围绕圆圈进行。 在跳过指定数量的人之后，执行下一个人。 对剩下的人重复该过程，从下一个人开始，朝同一方向跳过相同数量的人，直到只剩下一个人，并被释放。</p><p>问题即，给定人数、起点、方向和要跳过的数字，选择初始圆圈中的位置以避免被处决。</p></blockquote><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://img.jiangchen.tech/20210505012852.png" alt="双向链表"></p><p>从图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><h2 id="思考：如何基于链表实现-LRU-缓存淘汰算法？"><a href="#思考：如何基于链表实现-LRU-缓存淘汰算法？" class="headerlink" title="思考：如何基于链表实现 LRU 缓存淘汰算法？"></a>思考：如何基于链表实现 LRU 缓存淘汰算法？</h2><p>缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><p>思路如下：</p><p>我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li><p>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p></li><li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p></li></ol><p>如果此时缓存未满，则将此结点直接插入到链表的头部；</p><p>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</p><h2 id="对于指针的理解"><a href="#对于指针的理解" class="headerlink" title="对于指针的理解"></a>对于指针的理解</h2><p>对于指针的理解，只需要记住下面这句话就可以了：</p><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针；或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近人有些低潮，干什么都不得劲。工作也逐渐进入安逸区，没什么有挑战性的工作，都是对之前的重复。想着把计算机基础都好好补一下，系统性的梳理一下，中国大学慕课网上面的国家精品课程看一看，极客时间上面的一些课程也好好学习一下。&lt;/p&gt;
&lt;p&gt;以下的一些总结可能过于简陋，更多的是总纲性质的总结，更多的细枝末节，不懂为什么的，自己去找那些基础来看。简而言之，就是下面的总结很多只说了是什么，没有说为什么。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://blog.jiangchen.tech/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 RocketMQ 的一些总结</title>
    <link href="https://blog.jiangchen.tech/2018/12/61fe2e4c.html"/>
    <id>https://blog.jiangchen.tech/2018/12/61fe2e4c.html</id>
    <published>2018-12-19T00:00:00.000Z</published>
    <updated>2018-12-19T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开始做一个物联网项目，设备（终端）会向服务器发送心跳包以及其他数据，服务端的框架我使用了 netty 以及 spring-boot，考虑到后续随着设备数量的增多，现在的这种同步的模式，后续肯定会产生性能瓶颈。大概就 netty，数据库，设备这几部分，其实 netty 性能我是不担心的，但是数据一多，数据库肯定是会成为性能瓶颈。现在我把数据库这块，也就是业务这块，跟 netty 分离，netty 只处理终端上传的数据，处理完之后直接丢到 mq 里面。业务模块消费 mq 消息，将终端上传的数据持久化到数据库，供后续业务调用。</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RocketMQ 是一款阿里巴巴开源的消息中间件，基于 java 开发。以下是 Github 上关于 RocketMQ 的介绍：</p><p>RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。具有以下特性：</p><ul><li>支持发布&#x2F;订阅（Pub&#x2F;Sub）和点对点（P2P）消息模型</li><li>在一个队列中可靠的先进先出（FIFO）和严格的顺序传递</li><li>支持拉（pull）和推（push）两种消息模式</li><li>单一队列百万消息的堆积能力</li><li>支持多种消息协议，如 JMS、MQTT 等</li><li>分布式高可用的部署架构，满足至少一次消息传递语义</li><li>提供 docker 镜像用于隔离测试和云集群部署</li><li>提供配置、指标和监控等功能丰富的 Dashboard</li></ul><h1 id="RocketMQ-的下载安装以及启动"><a href="#RocketMQ-的下载安装以及启动" class="headerlink" title="RocketMQ 的下载安装以及启动"></a>RocketMQ 的下载安装以及启动</h1><h2 id="官网下载以及安装-RocketMQ"><a href="#官网下载以及安装-RocketMQ" class="headerlink" title="官网下载以及安装 RocketMQ"></a>官网下载以及安装 RocketMQ</h2><p>在 linux 上使用下载命令，如：<br>    wget <a href="http://mirror.bit.edu.cn/apache/rocketmq/4.3.2/rocketmq-all-4.3.2-source-release.zip">http://mirror.bit.edu.cn/apache/rocketmq/4.3.2/rocketmq-all-4.3.2-source-release.zip</a></p><p>下载压缩包，下载下来解压之后，使用 maven 编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">unzip rocketmq-all-4.3.2-source-release.zip</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cd</span> rocketmq-all-4.3.2/</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">mvn -Prelease-all -DskipTests clean install -U</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">cd</span> distribution/target/apache-rocketmq</span></span><br></pre></td></tr></table></figure><p>文件夹内就是我们需要的 mq 服务端了</p><h2 id="启动-name-server"><a href="#启动-name-server" class="headerlink" title="启动 name server"></a>启动 name server</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqnamesrv &amp;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line">  The Name Server boot success...</span><br></pre></td></tr></table></figure><h2 id="启动-broker"><a href="#启动-broker" class="headerlink" title="启动 broker"></a>启动 broker</h2><p>可以添加自动创建 topic 选项，但是生产环境中不建议开启这个选项，还是手动创建 topic 比较好，topic 对性能影响挺大的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqbroker -c conf/broker.conf &amp;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/broker.log</span></span><br><span class="line">  The broker[%s, 172.30.30.233:10911] boot success...</span><br></pre></td></tr></table></figure><h2 id="关闭相关服务"><a href="#关闭相关服务" class="headerlink" title="关闭相关服务"></a>关闭相关服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">sh bin/mqshutdown broker</span></span><br><span class="line">The mqbroker(36695) is running...</span><br><span class="line">Send shutdown request to mqbroker(36695) OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">sh bin/mqshutdown namesrv</span></span><br><span class="line">The mqnamesrv(36664) is running...</span><br><span class="line">Send shutdown request to mqnamesrv(36664) OK</span><br></pre></td></tr></table></figure><blockquote><p>Tips: 如果启动不成功，可以查看相关日志，看是否是环境缺失导致，或者是否没有创建 topic</p></blockquote><h2 id="图形化管理工具"><a href="#图形化管理工具" class="headerlink" title="图形化管理工具"></a>图形化管理工具</h2><p>github 上面 apache 官方维护着一个开源的项目 <a href="https://github.com/apache/rocketmq-externals">rocketmq-externals</a>，里面的<code>rocketmq-console</code>，是一个 Java Web 项目，可以通过图形化的界面来监控 RocketMQ 的状态，还是挺好用的，可以手动创建队列什么的，推荐使用。</p><h1 id="RocketMQ-与项目的集成"><a href="#RocketMQ-与项目的集成" class="headerlink" title="RocketMQ 与项目的集成"></a>RocketMQ 与项目的集成</h1><h2 id="spring-boot-starter-rocketmq"><a href="#spring-boot-starter-rocketmq" class="headerlink" title="spring-boot-starter-rocketmq"></a>spring-boot-starter-rocketmq</h2><p>apache 官方有一个 RocketMQ-Spring 项目 &#x3D;&#x3D;&gt; <a href="https://github.com/apache/rocketmq-spring/blob/master/README_zh_CN.md">传送门</a></p><p>但是本项目使用的是 github 上面开源的另一个项目，买好车他们团队开源出来的 <a href="https://github.com/maihaoche/rocketmq-spring-boot-starter">rocketmq-spring-boot-starter</a></p><h2 id="简单入门实例"><a href="#简单入门实例" class="headerlink" title="简单入门实例"></a>简单入门实例</h2><h3 id="添加-maven-依赖"><a href="#添加-maven-依赖" class="headerlink" title="添加 maven 依赖"></a>添加 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.maihaoche<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">rocketmq:</span></span><br><span class="line">      <span class="attr">name-server-address:</span> <span class="number">172.21</span><span class="number">.10</span><span class="number">.111</span><span class="string">:9876</span></span><br><span class="line">      <span class="comment"># 可选，如果无需发送消息则忽略该配置</span></span><br><span class="line">      <span class="attr">producer-group:</span> <span class="string">local_pufang_producer</span></span><br><span class="line">      <span class="comment"># 发送超时配置毫秒数，可选，默认 3000</span></span><br><span class="line">      <span class="attr">send-msg-timeout:</span> <span class="number">5000</span></span><br><span class="line">      <span class="comment"># 追溯消息具体消费情况的开关，默认打开</span></span><br><span class="line">      <span class="comment">#trace-enabled: false</span></span><br><span class="line">      <span class="comment"># 是否启用 VIP 通道，默认打开</span></span><br><span class="line">      <span class="comment">#vip-channel-enabled: false</span></span><br></pre></td></tr></table></figure><h3 id="程序入口添加注解开启自动装配"><a href="#程序入口添加注解开启自动装配" class="headerlink" title="程序入口添加注解开启自动装配"></a>程序入口添加注解开启自动装配</h3><p>在 springboot 应用主入口添加<code>@EnableMQConfiguration</code>注解开启自动装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableMQConfiguration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建消息体"><a href="#构建消息体" class="headerlink" title="构建消息体"></a>构建消息体</h3><p>通过我们提供的 Builder 类创建消息对象，详见 wiki</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBuilder.of(<span class="keyword">new</span> <span class="title class_">MSG_POJO</span>()).topic(<span class="string">&quot;some-msg-topic&quot;</span>).build();</span><br></pre></td></tr></table></figure><h3 id="创建发送方"><a href="#创建发送方" class="headerlink" title="创建发送方"></a>创建发送方</h3><p>详见 wiki：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MQProducer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoProducer</span> <span class="keyword">extends</span> <span class="title class_">AbstractMQProducer</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建消费方"><a href="#创建消费方" class="headerlink" title="创建消费方"></a>创建消费方</h3><p>详见 wiki： 支持<code>springEL</code>风格配置项解析，如存在<code>suclogger-test-cluster</code>配置项，会优先将 topic 解析为配置项对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MQConsumer(topic = &quot;$&#123;suclogger-test-cluster&#125;&quot;, consumerGroup = &quot;local_sucloger_dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> <span class="keyword">extends</span> <span class="title class_">AbstractMQPushConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">process</span><span class="params">(Object message, Map extMap)</span> &#123;</span><br><span class="line">        <span class="comment">// extMap 中包含 messageExt 中的属性和 message.properties 中的属性</span></span><br><span class="line">        System.out.println(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入发送者</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DemoProducer demoProducer;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line">demoProducer.syncSend(msg)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近开始做一个物联网项目，设备（终端）会向服务器发送心跳包以及其他数据，服务端的框架我使用了 netty 以及 spring-boot，考虑到后续随着设备数量的增多，现在的这种同步的模式，后续肯定会产生性能瓶颈。大概就 netty，数据库，设备这几部分，其实 netty 性能我是不担心的，但是数据一多，数据库肯定是会成为性能瓶颈。现在我把数据库这块，也就是业务这块，跟 netty 分离，netty 只处理终端上传的数据，处理完之后直接丢到 mq 里面。业务模块消费 mq 消息，将终端上传的数据持久化到数据库，供后续业务调用。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://blog.jiangchen.tech/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 docker 部署 spring-boot 项目</title>
    <link href="https://blog.jiangchen.tech/2018/06/d7382792.html"/>
    <id>https://blog.jiangchen.tech/2018/06/d7382792.html</id>
    <published>2018-06-14T00:00:00.000Z</published>
    <updated>2018-06-14T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近有个想法，就是在单机上面部署双实例来实现高可用，当一个实例修改之后重新启动部署的时候，另一个实例是可用的。于是，准备试试 docker。</p><h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><span id="more"></span><h1 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h1><h2 id="构建一个简单的-spring-boot-应用"><a href="#构建一个简单的-spring-boot-应用" class="headerlink" title="构建一个简单的 spring-boot 应用"></a>构建一个简单的 spring-boot 应用</h2><p>使用 idea 快速的搭建一个 spring-boot 应用，添加 web 依赖。</p><p>新增一个 controller 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DockerController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Docker!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增添-Docker-支持"><a href="#增添-Docker-支持" class="headerlink" title="增添 Docker 支持"></a>增添 Docker 支持</h2><p>在<code>pom.xml</code>文件中增添如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>image_name<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>src/main/docker<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Docker maven plugin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> docker-demo-0.0.1-SNAPSHOT.jar app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Jar 到镜像中，简单解释一下：</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个&#x2F;tmp 的目录，由于 Spring Boot 使用内置的 Tomcat 容器，Tomcat 默认使用&#x2F;tmp 作为工作目录。这个命令的效果是：在宿主机的&#x2F;var&#x2F;lib&#x2F;docker 目录下创建一个临时文件并把它链接到容器中的&#x2F;tmp 目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加 java.security.egd 的系统属性指向&#x2F;dev&#x2F;urandom 作为 ENTRYPOINT</li></ul><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p><h1 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h1><h2 id="Linux-下安装-Docker-环境"><a href="#Linux-下安装-Docker-环境" class="headerlink" title="Linux 下安装 Docker 环境"></a>Linux 下安装 Docker 环境</h2><p>Linux 环境下安装 Docker 较为简单，一句命令行即可搞定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-io</span><br></pre></td></tr></table></figure><h2 id="Windows-下安装-Docker-环境"><a href="#Windows-下安装-Docker-环境" class="headerlink" title="Windows 下安装 Docker 环境"></a>Windows 下安装 Docker 环境</h2><p>首先登录官网下载，可能会需要你注册登录一下。</p><p>下载下来安装好之后，可能需要重启一下，因为需要开启 hyper-V 支持，这是一种虚拟化支持。</p><p>重启好之后会发现 Docker 已经开始运行了，任务栏通知区域有一只小鲸鱼。</p><p>需要进行一下设置，在<code>General</code>选项卡里面勾选 <code>Expose daemon on tcp://localhost:2357 without TLS</code>，如果不勾选的话，等一下打包镜像的时候会打包失败。</p><p>然后就是还有一个可能会经常失败的就是下载镜像，处理办法就是更换一下国内的镜像源，在<code>C:\ProgramData\Docker\config</code>中新建<code>daemon.json</code>文件，若没有这个文件夹，可自己新建，文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;live-restore&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后重启 Docker，打开 powerShell 命令行，输入 <code>docker version</code> 可查看相关版本信息。</p><h1 id="使用-Docker-部署-Spring-boot-项目"><a href="#使用-Docker-部署-Spring-boot-项目" class="headerlink" title="使用 Docker 部署 Spring-boot 项目"></a>使用 Docker 部署 Spring-boot 项目</h1><p>对项目进行打包，运行测试，运行正常即可开始用 Docker 构建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打包</span></span><br><span class="line">mvn package</span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">java -jar docker-demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>看到 Spring-boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>构建成功之后，即可使用相关命令启动镜像了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 image_name</span><br></pre></td></tr></table></figure><p>启动镜像之后，可以使用<code>docker ps</code>来查看运行中的容器。每一次执行<code>run</code>命令都会生成一个容器，可以对容器执行<code>start</code>、<code>stop</code>等操作。</p><p>使用浏览器访问<code>http://localhost:8080</code>，发现返回：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>说明使用 Docker 部署 spring-boot 项目成功！</p><h1 id="附录：常用命令"><a href="#附录：常用命令" class="headerlink" title="附录：常用命令"></a>附录：常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行镜像 -d 指后台运行，-p 指定映射端口，本机端口映射容器端口</span></span><br><span class="line">docker run -d -p 8088:8080 [image]</span><br><span class="line"></span><br><span class="line">docker images <span class="comment">#查看构建好的镜像</span></span><br><span class="line"></span><br><span class="line">docker ps -a <span class="comment">#查看所有容器</span></span><br><span class="line"></span><br><span class="line">docker start [container] <span class="comment">#启动容器</span></span><br><span class="line"></span><br><span class="line">docker stop [container] <span class="comment">#停止容器</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">rm</span> [container] <span class="comment">#删除容器</span></span><br><span class="line"></span><br><span class="line">docker rmi [image] <span class="comment">#删除镜像</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近有个想法，就是在单机上面部署双实例来实现高可用，当一个实例修改之后重新启动部署的时候，另一个实例是可用的。于是，准备试试 docker。&lt;/p&gt;
&lt;h1 id=&quot;Docker-简介&quot;&gt;&lt;a href=&quot;#Docker-简介&quot; class=&quot;headerlink&quot; title=&quot;Docker 简介&quot;&gt;&lt;/a&gt;Docker 简介&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;</summary>
    
    
    
    <category term="docker" scheme="https://blog.jiangchen.tech/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 python 脚本下载图片</title>
    <link href="https://blog.jiangchen.tech/2018/05/835d5244.html"/>
    <id>https://blog.jiangchen.tech/2018/05/835d5244.html</id>
    <published>2018-05-26T00:00:00.000Z</published>
    <updated>2018-05-26T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没更新博客了，最近来一波更新吧。</p><p>咳咳，最近得到了一批纯洁图片的 url 地址，起因是有人用爬虫爬取纯洁网站的图片。刚好很久没折腾了，于是我想着使用 python 脚本，把它们都下载下来。</p><span id="more"></span><h2 id="第一个简单的版本：单进程下载"><a href="#第一个简单的版本：单进程下载" class="headerlink" title="第一个简单的版本：单进程下载"></a>第一个简单的版本：单进程下载</h2><p>话不多说，直接上代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;seePicture.db&#x27;</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;select * from picture&#x27;</span>)</span><br><span class="line"><span class="comment"># 执行查询语句</span></span><br><span class="line">values = cursor.fetchall()</span><br><span class="line"><span class="comment"># select 语句执行通过 fetchall（）拿到结果集，是一个 list，每个元素是 tuple</span></span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line">imgName = <span class="number">0</span></span><br><span class="line">li = []</span><br><span class="line">head = <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> values:</span><br><span class="line">    url = t[<span class="number">3</span>]</span><br><span class="line">    li.append(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">pic_url, headers</span>):</span><br><span class="line">    req = urllib.request.Request(pic_url)</span><br><span class="line">    req.add_header(<span class="string">&quot;User-Agent&quot;</span>, headers)</span><br><span class="line"></span><br><span class="line">    content = urllib.request.urlopen(req).read()</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&#x27;D:\\Temp\\pic\\&#x27;</span> + <span class="built_in">str</span>(imgName) + <span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        c = get_content(url, head)</span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="built_in">print</span>(url + <span class="string">&#x27; ok&#x27;</span>)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(url + <span class="string">&#x27; error&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    imgName += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All Done!&quot;</span>)</span><br></pre></td></tr></table></figure><p>简单解释一下，这个直接就是从 sqlite 中取出所有数据，因为本身数据量就不大，我看了下就一千多条记录，可以一次性全部取出。将取出的记录中的第 4 个字段，也就是图片地址那个字段取出来，组成一个新的 list。然后就是对这个 list 进行遍历，将它下载保存到<code>D:\Temp\pic</code>中。</p><p>刚开始我直接下载的时候我看报错信息是<code>HTTP Error 403: Forbidden</code>，于是我加上了请求头<code>User-Agent</code>，然后就能正常请求下载了。</p><h2 id="第二个版本：使用多进程，提高下载速度"><a href="#第二个版本：使用多进程，提高下载速度" class="headerlink" title="第二个版本：使用多进程，提高下载速度"></a>第二个版本：使用多进程，提高下载速度</h2><p>第一个版本里面，使用的是本地的 sqlite 数据库，其实就是一个几十 k 的文件，图片太少了。</p><p>然后我要到了数据库，看了下将近两百万条，这个应该够看了。跟上面相比只是连接的数据库不一样了，其他的都一样。</p><p>但是这样存在一个问题，就是下载太慢了，因为毕竟是单线程下载。然后我在网上看了好几份代码，结合了一下，同时修改了代码结构，整出一个多进程的版本，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spider</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_list</span>():</span><br><span class="line">        db = pymysql.connect(host=<span class="string">&quot;192.168.1.1&quot;</span>, user=<span class="string">&quot;root&quot;</span>, password=<span class="string">&quot;root&quot;</span>, db=<span class="string">&quot;db&quot;</span>, port=<span class="number">3306</span>)</span><br><span class="line">        <span class="comment"># 使用 cursor() 方法获取操作游标</span></span><br><span class="line">        cur = db.cursor()</span><br><span class="line">        <span class="comment"># 编写 sql 查询语句  user 对应我的表名</span></span><br><span class="line">        sql = <span class="string">&quot;SELECT * FROM picture WHERE id &gt; 0 LIMIT 4000&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cur.execute(sql)  <span class="comment"># 执行 sql 语句</span></span><br><span class="line">            results = cur.fetchall()  <span class="comment"># 获取查询的所有记录</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            db.close()  <span class="comment"># 关闭连接</span></span><br><span class="line">        url_list = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> results:</span><br><span class="line">            url = t[<span class="number">2</span>]</span><br><span class="line">            url_list.append(url)</span><br><span class="line">        <span class="keyword">return</span> url_list</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_pic</span>(<span class="params">pic_url, file_name</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resource = requests.get(pic_url)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file.write(resource.content)</span><br><span class="line">                <span class="built_in">print</span>(pic_url + <span class="string">&quot; ok&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(pic_url + <span class="string">&quot; error&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    spider = Spider()</span><br><span class="line">    urls = spider.get_list()</span><br><span class="line">    p = Pool(<span class="number">40</span>)</span><br><span class="line">    d1 = datetime.datetime.now()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> urls:</span><br><span class="line">        p.apply_async(spider.get_pic, args=(i, <span class="string">&#x27;D:\\Temp\\pic\\&#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27;.jpg&#x27;</span>))</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    d2 = datetime.datetime.now()</span><br><span class="line">    <span class="built_in">print</span>(d2 - d1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All Done!&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码主要是使用了多进程来执行任务，从而加快执行的速度。使用上述代码之后，我发现下载图片的速度相比原来大大提高，一下子就能下载好多张。</p><h2 id="第三个版本：直接命令行启动"><a href="#第三个版本：直接命令行启动" class="headerlink" title="第三个版本：直接命令行启动"></a>第三个版本：直接命令行启动</h2><p>有了上述版本之后，其实就已经能正常使用了，但是由于我是通过 ide，也就是 PyCharm 直接启动的，如果日常使用的话，会十分不方便。然后我就对它改造了一下，使得这个脚本直接可以在命令行里面启动，启动的时候给个参数就行。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spider</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_list</span>(<span class="params">num</span>):</span><br><span class="line">        db = pymysql.connect(host=<span class="string">&quot;192.168.1.1&quot;</span>, user=<span class="string">&quot;root&quot;</span>, password=<span class="string">&quot;root&quot;</span>, db=<span class="string">&quot;db&quot;</span>, port=<span class="number">3306</span>)</span><br><span class="line">        <span class="comment"># 使用 cursor() 方法获取操作游标</span></span><br><span class="line">        cur = db.cursor()</span><br><span class="line">        <span class="comment"># 编写 sql 查询语句  user 对应我的表名</span></span><br><span class="line">        sql = <span class="string">&#x27;SELECT * FROM picture WHERE id &gt; &#x27;</span> + num + <span class="string">&#x27; LIMIT 4000&#x27;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cur.execute(sql)  <span class="comment"># 执行 sql 语句</span></span><br><span class="line">            results = cur.fetchall()  <span class="comment"># 获取查询的所有记录</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            db.close()  <span class="comment"># 关闭连接</span></span><br><span class="line">        url_list = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> results:</span><br><span class="line">            url = t[<span class="number">2</span>]</span><br><span class="line">            url_list.append(url)</span><br><span class="line">        <span class="keyword">return</span> url_list</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_pic</span>(<span class="params">pic_url, file_name</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resource = requests.get(pic_url)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file.write(resource.content)</span><br><span class="line">                <span class="built_in">print</span>(pic_url + <span class="string">&quot; ok&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(pic_url + <span class="string">&quot; error&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arg = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;传入的参数为：&#x27;</span> + arg)</span><br><span class="line"></span><br><span class="line">    j = <span class="built_in">int</span>(arg) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    spider = Spider()</span><br><span class="line">    urls = spider.get_list(<span class="built_in">str</span>(j))</span><br><span class="line">    p = Pool(<span class="number">40</span>)</span><br><span class="line">    d1 = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> urls:</span><br><span class="line">        p.apply_async(spider.get_pic, args=(i, <span class="string">&#x27;D:\\Temp\\pic\\&#x27;</span> + <span class="built_in">str</span>(j) + <span class="string">&#x27;.jpg&#x27;</span>))</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    d2 = datetime.datetime.now()</span><br><span class="line">    <span class="built_in">print</span>(d2 - d1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All Done!&quot;</span>)</span><br></pre></td></tr></table></figure><p>主要是使用了<code>sys.argv[1]</code>这个变量，<code>sys.argv[0]</code>默认就是文件名，<code>sys.argv[1]</code>就是输入的第一个参数，另外就是注意一下哪里该用整数，哪里该用字符串。</p><p>在命令行环境下，假设这个 python 脚本名字为<code>spy.py</code>，启动的时候输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python spy.py 0</span><br></pre></td></tr></table></figure><p>即可开始运行脚本。</p><blockquote><p>注意：直接运行脚本的时候还要注意一个细节，就是引入的库是全局存在的，还是当前项目所引入的，不然可能会报<code>ModuleNotFoundError: No module named &#39;XXX&#39;</code>异常。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;好久没更新博客了，最近来一波更新吧。&lt;/p&gt;
&lt;p&gt;咳咳，最近得到了一批纯洁图片的 url 地址，起因是有人用爬虫爬取纯洁网站的图片。刚好很久没折腾了，于是我想着使用 python 脚本，把它们都下载下来。&lt;/p&gt;</summary>
    
    
    
    <category term="瞎折腾" scheme="https://blog.jiangchen.tech/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>JWT 和跨域的一些总结</title>
    <link href="https://blog.jiangchen.tech/2017/11/7680494f.html"/>
    <id>https://blog.jiangchen.tech/2017/11/7680494f.html</id>
    <published>2017-11-17T00:00:00.000Z</published>
    <updated>2017-11-17T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="一、什么是-JWT"><a href="#一、什么是-JWT" class="headerlink" title="一、什么是 JWT"></a>一、什么是 JWT</h2><blockquote><p>Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519)。该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。<code>JWT</code>的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p></blockquote><span id="more"></span><h2 id="二、JWT-的原理"><a href="#二、JWT-的原理" class="headerlink" title="二、JWT 的原理"></a>二、JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><pre><code>&#123;&quot;姓名&quot;: &quot;张三&quot;,&quot;角色&quot;: &quot;管理员&quot;,&quot;到期时间&quot;: &quot;2018 年 7 月 1 日 0 点 0 分&quot;&#125;</code></pre><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="三、JWT-的数据结构"><a href="#三、JWT-的数据结构" class="headerlink" title="三、JWT 的数据结构"></a>三、JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="JWT Token"></p><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><pre><code>Header（头部）Payload（负载）Signature（签名）</code></pre><p>写成一行，就是下面的样子。</p><pre><code>Header.Payload.Signature</code></pre><p>下面依次介绍这三个部分。</p><h3 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><pre><code>&#123;&quot;alg&quot;: &quot;HS256&quot;,&quot;typ&quot;: &quot;JWT&quot;&#125;</code></pre><p>上面代码中，alg 属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ 属性表示这个令牌（token）的类型（type），JWT 令牌统一写为 JWT。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了 7 个官方字段，供选用。</p><pre><code>iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号</code></pre><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><pre><code>&#123;&quot;sub&quot;: &quot;1234567890&quot;,&quot;name&quot;: &quot;John Doe&quot;,&quot;admin&quot;: true&#125;</code></pre><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><pre><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</code></pre><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com&#x2F;?token&#x3D;xxx）。Base64 有三个字符+、&#x2F;和&#x3D;，在 URL 里面有特殊含义，所以要被替换掉：&#x3D;被省略、+替换成-，&#x2F;替换成_ 。这就是 Base64URL 算法。</p><h2 id="四、JWT-的使用方式"><a href="#四、JWT-的使用方式" class="headerlink" title="四、JWT 的使用方式"></a>四、JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 Authorization 字段里面。</p><pre><code>Authorization: Bearer &lt;token&gt;</code></pre><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="五、JWT-的几个特点"><a href="#五、JWT-的几个特点" class="headerlink" title="五、JWT 的几个特点"></a>五、JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。</p><p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p><h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP 的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ul><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对这两种请求的处理，是不一样的。</p><h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><pre><code>GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。</p><p>如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8</code></pre><p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p><p>（1）Access-Control-Allow-Origin</p><p>该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个*，表示接受任意域名的请求。</p><p>（2）Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。</p><p>（3）Access-Control-Expose-Headers</p><p>该字段可选。<code>CORS</code>请求时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。上面的例子指定，getResponseHeader(‘FooBar’) 可以返回 FooBar 字段的值。</p><h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，<code>CORS</code>请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><pre><code>Access-Control-Allow-Credentials: true</code></pre><p>另一方面，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p><pre><code>var xhr = new XMLHttpRequest();xhr.withCredentials = true;</code></pre><p>否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p><p>但是，如果省略 withCredentials 设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials。</p><pre><code>xhr.withCredentials = false;</code></pre><p>需要注意的是，如果要发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。</p><h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application&#x2F;json。</p><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p><p>下面是一段浏览器的 JavaScript 脚本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://api.alice.com/cors&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;PUT&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;X-Custom-Header&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，HTTP 请求的方法是 PUT，并且发送一个自定义头信息 X-Custom-Header。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的 HTTP 头信息。</p><pre><code>OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>“预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是 Origin，表示请求来自哪个源。</p><p>除了 Origin 字段，”预检”请求的头信息包括两个特殊字段。</p><p>（1）Access-Control-Request-Method</p><p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。</p><p>（2）Access-Control-Request-Headers</p><p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header。</p><h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应。</p><pre><code>HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain</code></pre><p>上面的 HTTP 回应中，关键的是 Access-Control-Allow-Origin 字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><pre><code>Access-Control-Allow-Origin: *</code></pre><p>如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获。控制台会打印出如下的报错信息。</p><pre><code>XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</code></pre><p>服务器回应的其他 CORS 相关字段如下。</p><pre><code>Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000</code></pre><p>（1）Access-Control-Allow-Methods</p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p>（2）Access-Control-Allow-Headers</p><p>如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p>（3）Access-Control-Allow-Credentials</p><p>该字段与简单请求时的含义相同。</p><p>（4）Access-Control-Max-Age</p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p><h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息字段。</p><p>下面是”预检”请求之后，浏览器的正常 CORS 请求。</p><pre><code>PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...</code></pre><p>上面头信息的 Origin 字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><pre><code>Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8</code></pre><p>上面头信息中，Access-Control-Allow-Origin 字段是每次回应都必定包含的。</p><h2 id="五、与-JSONP-的比较"><a href="#五、与-JSONP-的比较" class="headerlink" title="五、与 JSONP 的比较"></a>五、与 JSONP 的比较</h2><p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。</p><p>JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JWT&quot;&gt;&lt;a href=&quot;#JWT&quot; class=&quot;headerlink&quot; title=&quot;JWT&quot;&gt;&lt;/a&gt;JWT&lt;/h1&gt;&lt;h2 id=&quot;一、什么是-JWT&quot;&gt;&lt;a href=&quot;#一、什么是-JWT&quot; class=&quot;headerlink&quot; title=&quot;一、什么是 JWT&quot;&gt;&lt;/a&gt;一、什么是 JWT&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Json web token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（(RFC 7519)。该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。&lt;code&gt;JWT&lt;/code&gt;的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开发总结" scheme="https://blog.jiangchen.tech/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 MySQL 若干问题的总结</title>
    <link href="https://blog.jiangchen.tech/2017/11/49552f71.html"/>
    <id>https://blog.jiangchen.tech/2017/11/49552f71.html</id>
    <published>2017-11-08T00:00:00.000Z</published>
    <updated>2017-11-08T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天碰到一个问题，就是往数据库存中文名字的时候，发现存不进去，错误提示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HY000][1366] Incorrect string value</span><br></pre></td></tr></table></figure><p>简单搜索了一下，发现可能是编码设置的问题，在 MySQL 中输入 <code>show variables like &#39;character%&#39;;</code> 命令，就可以看到自己的 MySQL 数据库相关的设置了，MySQL 默认的设置是 <code>Latin1</code>。我按照网上的相关说明，拷贝了一个 <code>my.cnf</code> 设置文件进去，设置好相关的编码，然后把数据表全删了，重新生成，发现还是插入不了中文数据，我当时有点奔溃。</p><span id="more"></span><p>这个时候，我就想了，是不是因为自己的 MySQL 版本太低了。因为用的是阿里云的 centOS 6.9 的系统，MySQL 是用 yum 安装的，版本是 5.1.73，算是比较低的了。</p><h4 id="升级-MySQL"><a href="#升级-MySQL" class="headerlink" title="升级 MySQL"></a>升级 MySQL</h4><p>于是，我去 MySQL 官网下载了一个 rpm 包，就是 mysql 的 repo，上传到服务器上，安装了之后一更新，把 MySQL 就升级到 5.7 了，但是这个时候我发现 MySQL 启动不了了。</p><h4 id="初始化-MySQL"><a href="#初始化-MySQL" class="headerlink" title="初始化 MySQL"></a>初始化 MySQL</h4><p>使用 <code>less /var/log/mysql.log</code> 命令查看 MySQL 的日志，发现说的大概意思好像是 ibdata1 分页大小什么的，在网上搜了下，按照相关步骤干脆把 <code>/var/lib/mysql</code> 里的文件全删除了。（注意：这里面有数据库文件，删除需谨慎）</p><p>然后执行 <code>mysqld --initialize --user=mysql</code> 初始化 MySQL。</p><p>这个时候执行 <code>service mysqld start</code>，发现能启动成功，但是登录的时候，发现原来的密码什么的不管用了，这个时候，应该安全启动 MySQL，就是不校验用户的那种。</p><p>先执行 <code>service mysqld stop</code> 把 MySQL 给关闭掉，然后安全启动 MySQL，有以下两种方式：</p><ol><li>在 <code>my.cnf</code> 文件中 [mysqld] 下面添加一行配置，<code>skip-grant-tables</code>，就是跳过鉴权，然后执行 <code>service mysqld start</code> 启动 MySQL</li><li>直接执行 <code>mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;</code></li></ol><p>使用上述两种方法都能够启动 MySQL，不需要密码就能使用 MySQL</p><h4 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h4><ul><li><p>输入 <code>mysql</code> 命令，启动 MySQL</p></li><li><p>执行 <code>mysql&gt; update user set authentication_string=PASSWORD(&#39;root&#39;) where user=&#39;root&#39;;</code>，重新设置密码</p></li><li><p>开启远程访问：<code>mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;IDENTIFIED BY &#39;jiangchen&#39; WITH GRANT OPTION;</code></p></li><li><p>再执行<code>mysql&gt; FLUSH PRIVILEGES;</code></p></li><li><p>这个时候退出数据库，正常启动，重新登陆之后，会发现提示修改密码，于是我们修改密码</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.</span><br><span class="line">mysql&gt; set PASSWORD=Password(&#x27;root&#x27;);</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>再执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter user root@localhost PASSWORD EXPIRE NEVER;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><p>这样密码就修改成功了，密码也不会提示过期了。</p><h4 id="修复-MySQL-不能存中文的问题"><a href="#修复-MySQL-不能存中文的问题" class="headerlink" title="修复 MySQL 不能存中文的问题"></a>修复 MySQL 不能存中文的问题</h4><p>上面一通折腾，只是重置了 MySQL 的密码，但是我存中文还是存不了，还得整 utf8 的问题。</p><p>于是我把编码按照之前做的又都设置为 utf8，具体操作步骤为在 <code>my.cnf</code> 配置文件中添加一行：<code>character-set-server=utf8</code></p><p>这样做了之后发现还是不行，删了表重新建也不行。</p><p>最后，我把 database 删除了，重新建了一个 database，然后生成表，发现这个时候就可以存中文了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>其实我没有必要升级数据库的，一开始设置好编码，删除库，重新建应该就好了。但是在这个过程中，也折腾了不少东西，学到了不少东西吧。数据库在创建的时候编码方式就设置好了，针对单张表除非特别声明，使用自定义的编码方式，不然都是默认的，尤其是我用的还是 jpa 的自动生成表。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天碰到一个问题，就是往数据库存中文名字的时候，发现存不进去，错误提示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[HY000][1366] Incorrect string value&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单搜索了一下，发现可能是编码设置的问题，在 MySQL 中输入 &lt;code&gt;show variables like &amp;#39;character%&amp;#39;;&lt;/code&gt; 命令，就可以看到自己的 MySQL 数据库相关的设置了，MySQL 默认的设置是 &lt;code&gt;Latin1&lt;/code&gt;。我按照网上的相关说明，拷贝了一个 &lt;code&gt;my.cnf&lt;/code&gt; 设置文件进去，设置好相关的编码，然后把数据表全删了，重新生成，发现还是插入不了中文数据，我当时有点奔溃。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://blog.jiangchen.tech/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
</feed>
